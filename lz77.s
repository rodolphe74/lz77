* 6809 assembly program generated by cmoc 0.1.83


	SECTION	code


___va_arg	IMPORT
_abs	IMPORT
_adddww	IMPORT
_atoi	IMPORT
_atol	IMPORT
_atoui	IMPORT
_atoul	IMPORT
_bsearch	IMPORT
_cmpdww	IMPORT
_compress	EXPORT


*******************************************************************************

* FUNCTION compress(): defined at lz77.c:68
_compress	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-16,S
* Formal parameter(s):
*      4,U:    2 bytes: input: unsigned char *
*      6,U:    2 bytes: iSize: int
*      8,U:    2 bytes: output: unsigned char *
*     10,U:    2 bytes: oSize: int
* Local non-static variable(s):
*    -16,U:    3 bytes: t: struct tupleStruct
*    -13,U:    2 bytes: q: struct emittedTupleStruct
*    -11,U:    3 bytes: $V00083: struct tupleStruct
*     -8,U:    2 bytes: index: int
*     -6,U:    2 bytes: dicIndexStart: int
*     -4,U:    2 bytes: dicIndexStop: int
*     -2,U:    2 bytes: outputIdx: int
* Line lz77.c:71: init of variable index
	CLRA
	CLRB
	STD	-8,U		variable index
* Line lz77.c:72: init of variable dicIndexStart
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	STD	-6,U		variable dicIndexStart
* Line lz77.c:72: init of variable dicIndexStop
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	STD	-4,U		variable dicIndexStop
* Line lz77.c:74: init of variable outputIdx
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	STD	-2,U		variable outputIdx
* Line lz77.c:75: while
	LBRA	L00085		jump to while condition
L00084	EQU	*		while body
* Line lz77.c:77: assignment: =
* Line lz77.c:77: conditional expression
	LDD	-8,U		variable index
	ADDD	#$FFE1		65505
	CMPD	#0
	BGE	L00088		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00087 removed
	CLRA
	CLRB
	BRA	L00089		end of true expression of conditional
L00088	EQU	*
	LDD	-8,U		variable index
	ADDD	#$FFE1		65505
L00089	EQU	*
	STD	-6,U
* Line lz77.c:78: assignment: =
* optim: stripConsecutiveLoadsToSameReg
	LDD	-8,U
	STD	-4,U
* Line lz77.c:82: init of variable t
	CLRA
	CLRB
	STB	-16,U		offset in variable t
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	STB	-15,U		offset in variable t
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	STB	-14,U		offset in variable t
* Line lz77.c:83: assignment: =
* Line lz77.c:83: function call: findInDic()
	LDY	#$07		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LDX	-8,U		optim: transformPshsDPshsD
	PSHS	Y,X		optim: optimizePshsOps
	LDY	-4,U		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LDX	-6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable `input', declared at lz77.c:68
	PSHS	Y,X,B,A		optim: optimizePshsOps
	LEAX	-11,U		address of struct/union to be returned by findInDic()
	PSHS	X		hidden argument
	LBSR	_findInDic
	LEAS	12,S
	LEAX	-11,U		address of struct/union returned by findInDic()
	LDD	#3		size of struct tupleStruct
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-16,U		variable `t', declared at lz77.c:82
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line lz77.c:86: function call: toEmittedTuple()
	LEAY	-13,U		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LEAX	-16,U		variable `t', declared at lz77.c:82
	PSHS	Y,X		optim: optimizePshsOps
	LBSR	_toEmittedTuple
	LEAS	4,S
* Line lz77.c:87: function call: memcpy()
	CLRA
	LDB	#$02		constant expression: 2 decimal, unsigned
	PSHS	B,A		argument 3 of memcpy(): unsigned int
	LEAX	-13,U		variable `q', declared at lz77.c:85
* optim: optimizePshsOps
	LDD	-2,U		variable `outputIdx', declared at lz77.c:74
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	8,U		variable `output', declared at lz77.c:68
	ADDD	,S++
	PSHS	B,A		argument 1 of memcpy(): unsigned char *
	LBSR	_memcpy
	LEAS	6,S
* Line lz77.c:88: assignment: +=
	LDD	-2,U		variable outputIdx
	ADDD	#$02		+= operator at lz77.c:88
	STD	-2,U
* Line lz77.c:90: assignment: +=
	LDB	-15,U		member l of tupleStruct, via variable t
	CLRA			promotion of binary operand
* optim: optimizeStackOperations2
* optim: optimizeStackOperations2
* optim: stripPushLeas1
	ADDB	#$01		optim: optimizeStackOperations2
* optim: stripExtraClrA_B
	ADDD	-8,U		optim: pushDLoadAdd
* 
* 
	STD	-8,U
L00085	EQU	*		while condition at lz77.c:75
	LDD	-8,U		variable index
	CMPD	6,U		variable iSize
	LBLT	L00084
* optim: branchToNextLocation
* Useless label L00086 removed
* Line lz77.c:92: return with value
	LDD	-2,U		variable `outputIdx', declared at lz77.c:74
* optim: branchToNextLocation
* Useless label L00081 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION compress(): defined at lz77.c:68
funcend_compress	EQU *
funcsize_compress	EQU	funcend_compress-_compress
_delay	IMPORT
_divdwb	IMPORT
_divdww	IMPORT
_divmod16	IMPORT
_divmod8	IMPORT
_dwtoa	IMPORT
_enableCMOCFloatSupport	IMPORT
_exit	IMPORT
_findInDic	EXPORT


*******************************************************************************

* FUNCTION findInDic(): defined at lz77.c:23
_findInDic	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-15,S
* Formal parameter(s):
*      6,U:    2 bytes: input: unsigned char *
*      8,U:    2 bytes: startDicIndex: int
*     10,U:    2 bytes: stopDicIndex: int
*     12,U:    2 bytes: startAHead: int
*     15,U:    1 byte : aHeadSize: unsigned char
* Local non-static variable(s):
*    -12,U:    3 bytes: t: struct tupleStruct
*     -9,U:    1 byte : match: unsigned char
*     -8,U:    2 bytes: i: int
*     -6,U:    2 bytes: j: int
*     -4,U:    2 bytes: k: int
*     -2,U:    2 bytes: maxK: int
* Line lz77.c:26: if
	LDD	12,U		variable startAHead
	CMPD	8,U		variable startDicIndex
	BNE	L00091		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00090 removed
* Line lz77.c:26
* Line lz77.c:27: init of variable t
	CLRA
	CLRB
	STB	-15,U		offset in variable t
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	STB	-14,U		offset in variable t
	LDD	12,U		variable startAHead
	LDX	6,U		pointer input
* optimizeLoadDX
	LDB	D,X		get r-value
	STB	-13,U		offset in variable t
* Line lz77.c:28: return struct/union by value
	LEAX	-15,U		variable `t', declared at lz77.c:27
	PSHS	X		source struct/union
	LDX	4,U		address of return value
	LDD	#3		size of struct tupleStruct
	LBSR	copyMem
	LEAS	2,S		discard copyMem argument
	LBRA	L00080		return (lz77.c:28)
L00091	EQU	*		else clause of if() started at lz77.c:26
* Useless label L00092 removed
* Line lz77.c:31: init of variable t
	CLRA
	CLRB
	STB	-12,U		offset in variable t
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	STB	-11,U		offset in variable t
	LDD	12,U		variable startAHead
	LDX	6,U		pointer input
* optimizeLoadDX
	LDB	D,X		get r-value
	STB	-10,U		offset in variable t
* Line lz77.c:32: init of variable match
	CLR	-9,U		variable match
* Line lz77.c:33: init of variable i
	CLRA
	CLRB
	STD	-8,U		variable i
* Line lz77.c:33: init of variable j
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	STD	-6,U		variable j
* Line lz77.c:33: init of variable k
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	STD	-4,U		variable k
* Line lz77.c:34: init of variable maxK
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	STD	-2,U		variable maxK
* Line lz77.c:35: while
	LBRA	L00094		jump to while condition
L00093	EQU	*		while body
* Line lz77.c:37: for init
* Line lz77.c:37: assignment: =
* optim: stripConsecutiveLoadsToSameReg
	LDD	12,U
	STD	-8,U
	LBRA	L00097		jump to for condition
L00096	EQU	*
* Line lz77.c:37: for body
* Line lz77.c:38: assignment: =
	CLR	-9,U		variable match
* Line lz77.c:39: for init
* Line lz77.c:39: assignment: =
* optim: stripConsecutiveLoadsToSameReg
	LDD	8,U
	STD	-6,U
	BRA	L00101		jump to for condition
L00100	EQU	*
* Line lz77.c:39: for body
* Line lz77.c:40: if
	LDD	12,U		variable startAHead
	LDX	6,U		pointer input
* optimizeLoadDX
	LDB	D,X		get r-value
	PSHS	B
	LDD	-6,U		variable j
	LDX	6,U		pointer input
* optimizeLoadDX
	LDB	D,X		get r-value
	CMPB	,S+		compare with LSB
	BNE	L00105		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00104 removed
* Line lz77.c:40
* Line lz77.c:42: assignment: =
	LDB	#$01
	STB	-9,U		variable match
	BRA	L00103		break
L00105	EQU	*		else clause of if() started at lz77.c:40
* Useless label L00106 removed
* Useless label L00102 removed
* Line lz77.c:39: for increment(s)
	LDD	-6,U
	ADDD	#1
	STD	-6,U
L00101	EQU	*
* Line lz77.c:39: for condition
	LDD	-6,U		variable j
	CMPD	10,U		variable stopDicIndex
	BLT	L00100
* optim: branchToNextLocation
L00103	EQU	*		end for
* Line lz77.c:46: if
	LDB	-9,U		variable `match', declared at lz77.c:32
* optim: loadCmpZeroBeqOrBne
	LBEQ	L00108		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00107 removed
* Line lz77.c:46
* Line lz77.c:47: assignment: =
	CLRA
	LDB	#$01		decimal 1 signed
	STD	-4,U
* Line lz77.c:48: while
	BRA	L00110		jump to while condition
L00109	EQU	*		while body
* Line lz77.c:49: post-increment
	LDX	-4,U		variable `k', declared at lz77.c:49
	LEAX	1,X
	STX	-4,U
L00110	EQU	*		while condition at lz77.c:48
	LDB	15,U		variable aHeadSize
	ADDB	#$FF		255
	CLRA			promotion of binary operand
* optim: optimize16BitCompares
* optim: optimize16BitCompares
	CMPD	-4,U		optim: optimize16BitCompares
	BLS	L00111		optim: optimize16BitCompares (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00112 removed
	LDD	12,U		variable startAHead
	ADDD	-4,U		variable k
	LDX	6,U		pointer input
* optimizeLoadDX
	LDB	D,X		get r-value
	PSHS	B
	LDD	-6,U		variable j
	ADDD	-4,U		variable k
	LDX	6,U		pointer input
* optimizeLoadDX
	LDB	D,X		get r-value
	CMPB	,S+		compare with LSB
	BEQ	L00109
* optim: branchToNextLocation
L00111	EQU	*		after end of while starting at lz77.c:48
* Line lz77.c:52: if
	LDD	-4,U		variable k
	CMPD	-2,U		variable maxK
	BLE	L00099		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00113 removed
* Line lz77.c:52
* Line lz77.c:53: assignment: =
	LDD	-8,U		variable i
	SUBD	-6,U		variable j
* Cast from `int' to byte: result already in B
* optim: stripExtraPushPullB
* optim: optimizeLeax
* optim: stripExtraPushPullB
	STB	-12,U		optim: optimizeLeax
* Line lz77.c:54: assignment: =
	LDD	-4,U		variable `k', declared at lz77.c:33
* Cast from `int' to byte: result already in B
* optim: stripExtraPushPullB
* optim: optimizeLeax
* optim: stripExtraPushPullB
	STB	-11,U		optim: optimizeLeax
* Line lz77.c:55: assignment: =
	LDD	12,U		variable startAHead
	ADDD	-4,U		variable k
	LDX	6,U		pointer input
* optimizeLoadDX
	LDB	D,X		get r-value
* optim: stripExtraPushPullB
* optim: optimizeLeax
* optim: stripExtraPushPullB
	STB	-10,U		optim: optimizeLeax
* Line lz77.c:56: assignment: =
* optim: stripConsecutiveLoadsToSameReg
	LDD	-4,U
	STD	-2,U
* Useless label L00114 removed
* Useless label L00115 removed
	BRA	L00099		break
L00108	EQU	*		else clause of if() started at lz77.c:46
* Useless label L00116 removed
* Useless label L00098 removed
* Line lz77.c:37: for increment(s)
	LDD	-8,U
	ADDD	#1
	STD	-8,U
L00097	EQU	*
* Line lz77.c:37: for condition
	LDB	15,U		variable `aHeadSize', declared at lz77.c:23
	CLRA			promotion of binary operand
	ADDD	12,U		optim: pushDLoadAdd
* 
* 
* optim: optimize16BitCompares
* optim: optimize16BitCompares
	CMPD	-8,U		optim: optimize16BitCompares
	LBGT	L00096		optim: optimize16BitCompares
* optim: branchToNextLocation
L00099	EQU	*		end for
* Line lz77.c:63: post-increment
	LDX	8,U		variable `startDicIndex', declared at lz77.c:63
	LEAX	1,X
	STX	8,U
L00094	EQU	*		while condition at lz77.c:35
	LDD	8,U		variable startDicIndex
	CMPD	10,U		variable stopDicIndex
	LBLT	L00093
* optim: branchToNextLocation
* Useless label L00095 removed
* Line lz77.c:65: return struct/union by value
	LEAX	-12,U		variable `t', declared at lz77.c:31
	PSHS	X		source struct/union
	LDX	4,U		address of return value
	LDD	#3		size of struct tupleStruct
	LBSR	copyMem
	LEAS	2,S		discard copyMem argument
* optim: branchToNextLocation
L00080	EQU	*		end of findInDic()
	LEAS	,U
	PULS	U,PC
* END FUNCTION findInDic(): defined at lz77.c:23
funcend_findInDic	EQU *
funcsize_findInDic	EQU	funcend_findInDic-_findInDic
_fromEmittedTuple	EXPORT


*******************************************************************************

* FUNCTION fromEmittedTuple(): defined at lz77.c:16
_fromEmittedTuple	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
* Formal parameter(s):
*      4,U:    2 bytes: q: const struct emittedTupleStruct *
*      6,U:    2 bytes: t: struct tupleStruct *
* Line lz77.c:18: assignment: =
	CLRA
	LDB	#$F8		decimal 248 signed
	PSHS	B
* optim: optimizeLdx
	LDB	[4,U]		optim: optimizeLdx
	ANDB	,S+
	LSRB
	LSRB
	LSRB
* optim: stripExtraPushPullB
* optim: optimizeLdx
* optim: stripExtraPushPullB
	STB	[6,U]		optim: optimizeLdx
* Line lz77.c:19: assignment: =
* optim: stripExtraClrA_B
	LDB	#$07		decimal 7 signed
	PSHS	B
* optim: optimizeLdx
	LDB	[4,U]		optim: optimizeLdx
	ANDB	,S+
* optim: stripExtraPushPullB
	LDX	6,U		variable t
* optim: optimizeLeax
* optim: stripExtraPushPullB
	STB	1,X		optim: optimizeLeax
* Line lz77.c:20: assignment: =
	LDX	4,U		variable q
	LDB	1,X		member c of emittedTupleStruct
* optim: stripExtraPushPullB
	LDX	6,U		variable t
* optim: optimizeLeax
* optim: stripExtraPushPullB
	STB	2,X		optim: optimizeLeax
* Useless label L00079 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION fromEmittedTuple(): defined at lz77.c:16
funcend_fromEmittedTuple	EQU *
funcsize_fromEmittedTuple	EQU	funcend_fromEmittedTuple-_fromEmittedTuple
_isalnum	IMPORT
_isalpha	IMPORT
_isdigit	IMPORT
_isspace	IMPORT
_itoa10	IMPORT
_labs	IMPORT
_ltoa10	IMPORT
_memchr	IMPORT
_memcmp	IMPORT
_memcpy	IMPORT
_memichr	IMPORT
_memicmp	IMPORT
_memmove	IMPORT
_memset	IMPORT
_memset16	IMPORT
_mulwb	IMPORT
_mulww	IMPORT
_printf	IMPORT
_putchar	IMPORT
_putstr	IMPORT
_qsort	IMPORT
_rand	IMPORT
_readbits	IMPORT
_readline	IMPORT
_readword	IMPORT
_sbrk	IMPORT
_sbrkmax	IMPORT
_setConsoleOutHook	IMPORT
_set_null_ptr_handler	IMPORT
_set_stack_overflow_handler	IMPORT
_sprintf	IMPORT
_sqrt16	IMPORT
_sqrt32	IMPORT
_srand	IMPORT
_strcat	IMPORT
_strchr	IMPORT
_strcmp	IMPORT
_strcpy	IMPORT
_stricmp	IMPORT
_strlen	IMPORT
_strlwr	IMPORT
_strncmp	IMPORT
_strncpy	IMPORT
_strstr	IMPORT
_strtol	IMPORT
_strtoul	IMPORT
_strupr	IMPORT
_subdww	IMPORT
_toEmittedTuple	EXPORT


*******************************************************************************

* FUNCTION toEmittedTuple(): defined at lz77.c:9
_toEmittedTuple	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
* Formal parameter(s):
*      4,U:    2 bytes: t: const struct tupleStruct *
*      6,U:    2 bytes: q: struct emittedTupleStruct *
* Line lz77.c:11: assignment: =
	CLRA
	LDB	#$1F		decimal 31 signed
	PSHS	B
* optim: optimizeLdx
	LDB	[4,U]		optim: optimizeLdx
	ANDB	,S+
	LSLB
	LSLB
	LSLB
* optim: stripExtraPushPullB
* optim: optimizeLdx
* optim: stripExtraPushPullB
	STB	[6,U]		optim: optimizeLdx
* Line lz77.c:12: assignment: |=
* optim: stripExtraClrA_B
	LDB	#$07		decimal 7 signed
	PSHS	B
	LDX	4,U		variable t
	LDB	1,X		member l of tupleStruct
	ANDB	,S+
	PSHS	B
	LDX	6,U		variable q
	LDB	,X
	ORB	,S+
	STB	,X
* Line lz77.c:13: assignment: =
	LDX	4,U		variable t
	LDB	2,X		member c of tupleStruct
* optim: stripExtraPushPullB
	LDX	6,U		variable q
* optim: optimizeLeax
* optim: stripExtraPushPullB
	STB	1,X		optim: optimizeLeax
* Useless label L00078 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION toEmittedTuple(): defined at lz77.c:9
funcend_toEmittedTuple	EQU *
funcsize_toEmittedTuple	EQU	funcend_toEmittedTuple-_toEmittedTuple
_tolower	IMPORT
_toupper	IMPORT
_ultoa10	IMPORT
_uncompress	EXPORT


*******************************************************************************

* FUNCTION uncompress(): defined at lz77.c:95
_uncompress	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-9,S
* Formal parameter(s):
*      4,U:    2 bytes: input: unsigned char *
*      6,U:    2 bytes: iSize: int
*      8,U:    2 bytes: output: unsigned char *
*     10,U:    2 bytes: oSize: int
* Local non-static variable(s):
*     -9,U:    2 bytes: q: struct emittedTupleStruct
*     -7,U:    3 bytes: t: struct tupleStruct
*     -4,U:    2 bytes: inputIdx: int
*     -2,U:    2 bytes: outputIdx: int
* Line lz77.c:97: init of variable inputIdx
	CLRA
	CLRB
	STD	-4,U		variable inputIdx
* Line lz77.c:97: init of variable outputIdx
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	STD	-2,U		variable outputIdx
* Line lz77.c:98: function call: memset()
	LDD	10,U		variable `oSize', declared at lz77.c:95
	PSHS	B,A		argument 3 of memset(): int
	CLRA
	CLRB
	PSHS	B,A		argument 2 of memset(): int
	LDD	8,U		variable `output', declared at lz77.c:95
	PSHS	B,A		argument 1 of memset(): unsigned char *
	LBSR	_memset
	LEAS	6,S
* Line lz77.c:100: while
	LBRA	L00118		jump to while condition
L00117	EQU	*		while body
* Line lz77.c:102: init of variable q
	LDD	-4,U		variable inputIdx
	LDX	4,U		pointer input
* optimizeLoadDX
	LDB	D,X		get r-value
	STB	-9,U		offset in variable q
	LDD	-4,U		variable inputIdx
	ADDD	#$01		1
	LDX	4,U		pointer input
* optimizeLoadDX
	LDB	D,X		get r-value
	STB	-8,U		offset in variable q
* Line lz77.c:104: function call: fromEmittedTuple()
	LEAY	-7,U		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LEAX	-9,U		variable `q', declared at lz77.c:102
	PSHS	Y,X		optim: optimizePshsOps
	LBSR	_fromEmittedTuple
	LEAS	4,S
* Line lz77.c:106: if
	LDB	-7,U		member d of tupleStruct, via variable t
* optim: loadCmpZeroBeqOrBne
	BEQ	L00121		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00120 removed
* Line lz77.c:106
* Line lz77.c:107: function call: memcpy()
	LDB	-6,U		member l of tupleStruct, via variable t
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of memcpy(): unsigned char
	LDB	-7,U		member d of tupleStruct, via variable t
* optim: stripExtraClrA_B
	PSHS	B,A
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDD	8,U		variable `output', declared at lz77.c:95
	ADDD	-2,U		optim: optimizeStackOperations4
	SUBD	,S++
	PSHS	B,A		argument 2 of memcpy(): unsigned char *
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDD	8,U		variable `output', declared at lz77.c:95
	ADDD	-2,U		optim: optimizeStackOperations4
	PSHS	B,A		argument 1 of memcpy(): unsigned char *
	LBSR	_memcpy
	LEAS	6,S
* Line lz77.c:108: assignment: +=
	LDB	-6,U		member l of tupleStruct, via variable t
	CLRA
	ADDD	-2,U		optim: pushDLoadAdd
* 
* 
	STD	-2,U
L00121	EQU	*		else clause of if() started at lz77.c:106
* Useless label L00122 removed
* Line lz77.c:111: assignment: =
	LDB	-5,U		member c of tupleStruct, via variable t
	PSHS	B
	LDD	-2,U		variable `outputIdx', declared at lz77.c:111
	ADDD	#1
	STD	-2,U
	SUBD	#1		post increment yields initial value
	LDX	8,U		pointer output
	LEAX	D,X		add offset
	LDB	,S+
	STB	,X
* Line lz77.c:116: assignment: +=
	LDD	-4,U		variable inputIdx
	ADDD	#$02		+= operator at lz77.c:116
	STD	-4,U
L00118	EQU	*		while condition at lz77.c:100
	LDD	-4,U		variable inputIdx
	CMPD	6,U		variable iSize
	LBLT	L00117
* optim: branchToNextLocation
* Useless label L00119 removed
* Line lz77.c:118: return with value
	LDD	-2,U		variable `outputIdx', declared at lz77.c:97
* optim: branchToNextLocation
* Useless label L00082 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION uncompress(): defined at lz77.c:95
funcend_uncompress	EQU *
funcsize_uncompress	EQU	funcend_uncompress-_uncompress
_utoa10	IMPORT
_vprintf	IMPORT
_vsprintf	IMPORT
_writebits	IMPORT
_zerodw	IMPORT


	ENDSECTION




	SECTION	initgl




*******************************************************************************

* Initialize global variables.


	ENDSECTION




	SECTION	rodata


string_literals_start	EQU	*
string_literals_end	EQU	*


*******************************************************************************

* READ-ONLY GLOBAL VARIABLES


	ENDSECTION




	SECTION	rwdata


* Statically-initialized global variables
* Statically-initialized local static variables


	ENDSECTION




	SECTION	bss


bss_start	EQU	*
* Uninitialized global variables
* Uninitialized local static variables
bss_end	EQU	*


	ENDSECTION




*******************************************************************************

* Importing 3 utility routine(s).
_memcpy	IMPORT
_memset	IMPORT
copyMem	IMPORT


*******************************************************************************

	END
