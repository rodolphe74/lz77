* 6809 assembly program generated by cmoc 0.1.83


	SECTION	code


_lps	IMPORT
_dicSize	IMPORT
_dicBitSize	IMPORT
_aheadSize	IMPORT
_aheadBitSize	IMPORT
_dicBitSize	EXPORT
_dicSize	EXPORT
_aheadBitSize	EXPORT
_aheadSize	EXPORT
_lps	EXPORT
___va_arg	IMPORT
_abs	IMPORT
_adddww	IMPORT
_atoi	IMPORT
_atol	IMPORT
_atoui	IMPORT
_atoul	IMPORT
_bruteForceSearch	EXPORT


*******************************************************************************

* FUNCTION bruteForceSearch(): defined at lz77.c:105
_bruteForceSearch	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-4,S
* Formal parameter(s):
*      4,U:    2 bytes: x: unsigned char *
*      6,U:    2 bytes: m: int
*      8,U:    2 bytes: y: unsigned char *
*     10,U:    2 bytes: n: int
* Local non-static variable(s):
*     -4,U:    2 bytes: i: int
*     -2,U:    2 bytes: j: int
* Line lz77.c:109: for init
* Line lz77.c:109: assignment: =
	CLRA
	CLRB
	STD	-2,U
	BRA	L00099		jump to for condition
L00098	EQU	*
* Line lz77.c:109: for body
* Line lz77.c:110: for init
* Line lz77.c:110: assignment: =
	CLRA
	CLRB
	STD	-4,U
	BRA	L00103		jump to for condition
L00102	EQU	*
* Line lz77.c:110: for body
* Useless label L00104 removed
* Line lz77.c:110: for increment(s)
	LDD	-4,U
	ADDD	#1
	STD	-4,U
L00103	EQU	*
* Line lz77.c:110: for condition
	LDD	-4,U		variable i
	CMPD	6,U		variable m
	BGE	L00105		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00106 removed
	LDD	-4,U		variable i
	ADDD	-2,U		variable j
	LDX	8,U		pointer y
* optimizeLoadDX
	LDB	D,X		get r-value
	PSHS	B
	LDD	-4,U		variable i
	LDX	4,U		pointer x
* optimizeLoadDX
	LDB	D,X		get r-value
	CMPB	,S+		compare with LSB
	BEQ	L00102
* optim: branchToNextLocation
L00105	EQU	*		end for
* Line lz77.c:111: if
	LDD	-4,U		variable i
	CMPD	6,U		variable m
	BLT	L00108		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00107 removed
* Line lz77.c:112
* Line lz77.c:112: return with value
	LDD	-2,U		variable `j', declared at lz77.c:107
	BRA	L00089		return (lz77.c:112)
L00108	EQU	*		else clause of if() started at lz77.c:111
* Useless label L00109 removed
* Useless label L00100 removed
* Line lz77.c:109: for increment(s)
	LDD	-2,U
	ADDD	#1
	STD	-2,U
L00099	EQU	*
* Line lz77.c:109: for condition
	LDD	10,U		variable n
	SUBD	6,U		variable m
* optim: optimize16BitCompares
* optim: optimize16BitCompares
	CMPD	-2,U		optim: optimize16BitCompares
	BGE	L00098		optim: optimize16BitCompares
* optim: branchToNextLocation
* Useless label L00101 removed
* Line lz77.c:114: return with value
	LDD	#$FFFF		constant expression: 65535 decimal, signed
* optim: branchToNextLocation
L00089	EQU	*		end of bruteForceSearch()
	LEAS	,U
	PULS	U,PC
* END FUNCTION bruteForceSearch(): defined at lz77.c:105
funcend_bruteForceSearch	EQU *
funcsize_bruteForceSearch	EQU	funcend_bruteForceSearch-_bruteForceSearch
_bruteForceSearchOptim	EXPORT


*******************************************************************************

* FUNCTION bruteForceSearchOptim(): defined at lz77.c:117
_bruteForceSearchOptim	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-4,S
* Formal parameter(s):
*      4,U:    2 bytes: x: unsigned char *
*      6,U:    2 bytes: m: int
*      8,U:    2 bytes: y: unsigned char *
*     10,U:    2 bytes: n: int
* Local non-static variable(s):
*     -4,U:    2 bytes: yb: unsigned char *
*     -2,U:    2 bytes: i: int
* Line lz77.c:120: init of variable i
	CLRA
	CLRB
	STD	-2,U		variable i
* Line lz77.c:123: for init
* Line lz77.c:123: assignment: =
* optim: stripConsecutiveLoadsToSameReg
	LDD	8,U
	STD	-4,U
	BRA	L00111		jump to for condition
L00110	EQU	*
* Line lz77.c:123: for body
* Line lz77.c:124: if
* Line lz77.c:124: function call: memcmp()
	LDD	6,U		variable `m', declared at lz77.c:117
	PSHS	B,A		argument 3 of memcmp(): int
	LDD	8,U		variable `y', declared at lz77.c:117
	PSHS	B,A		argument 2 of memcmp(): unsigned char *
	LDD	4,U		variable `x', declared at lz77.c:117
	PSHS	B,A		argument 1 of memcmp(): unsigned char *
	LBSR	_memcmp
	LEAS	6,S
	ADDD	#0
	BNE	L00115		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00114 removed
* Line lz77.c:125
* Line lz77.c:125: return with value
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDD	8,U		variable `y', declared at lz77.c:117
	SUBD	-4,U		optim: optimizeStackOperations4
* Emitted no code to cast `unsigned int' to `int'
	BRA	L00090		return (lz77.c:125)
L00115	EQU	*		else clause of if() started at lz77.c:124
* Useless label L00116 removed
* Useless label L00112 removed
* Line lz77.c:123: for increment(s)
	LDD	8,U		variable `y', declared at lz77.c:123
	ADDD	#1
	STD	8,U
	LDD	-2,U		variable `i', declared at lz77.c:123
	ADDD	#1
	STD	-2,U
* optim: removeUselessOps
L00111	EQU	*
* Line lz77.c:123: for condition
	LDD	10,U		variable n
	SUBD	6,U		variable m
* optim: optimize16BitCompares
* optim: optimize16BitCompares
	CMPD	-2,U		optim: optimize16BitCompares
	BGE	L00110		optim: optimize16BitCompares
* optim: branchToNextLocation
* Useless label L00113 removed
* Line lz77.c:127: return with value
	LDD	#$FFFF		constant expression: 65535 decimal, signed
* optim: branchToNextLocation
L00090	EQU	*		end of bruteForceSearchOptim()
	LEAS	,U
	PULS	U,PC
* END FUNCTION bruteForceSearchOptim(): defined at lz77.c:117
funcend_bruteForceSearchOptim	EQU *
funcsize_bruteForceSearchOptim	EQU	funcend_bruteForceSearchOptim-_bruteForceSearchOptim
_bsearch	IMPORT
_cmpdww	IMPORT
_compress	EXPORT


*******************************************************************************

* FUNCTION compress(): defined at lz77.c:269
_compress	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-21,S
* Formal parameter(s):
*      4,U:    2 bytes: input: unsigned char *
*      6,U:    2 bytes: iSize: unsigned int
*      8,U:    2 bytes: output: unsigned char *
*     10,U:    2 bytes: oSize: unsigned int
* Local non-static variable(s):
*    -21,U:    5 bytes: t: struct tupleStruct
*    -16,U:    5 bytes: $V00097: struct tupleStruct
*    -11,U:    5 bytes: bf: struct bitFieldStruct
*     -6,U:    2 bytes: index: int
*     -4,U:    2 bytes: dicIndexStart: int
*     -2,U:    2 bytes: dicIndexStop: int
* Line lz77.c:272: function call: memset()
	LDD	10,U		variable `oSize', declared at lz77.c:269
	PSHS	B,A		argument 3 of memset(): unsigned int
	CLRA
	CLRB
	PSHS	B,A		argument 2 of memset(): int
	LDD	8,U		variable `output', declared at lz77.c:269
	PSHS	B,A		argument 1 of memset(): unsigned char *
	LBSR	_memset
	LEAS	6,S
* Line lz77.c:274: function call: initBitField()
	LDD	8,U		variable `output', declared at lz77.c:269
	PSHS	B,A		argument 2 of initBitField(): unsigned char *
	LEAX	-11,U		variable `bf', declared at lz77.c:273
	PSHS	X		argument 1 of initBitField(): struct bitFieldStruct *
	LBSR	_initBitField
	LEAS	4,S
* Line lz77.c:276: init of variable index
	CLRA
	CLRB
	STD	-6,U		variable index
* Line lz77.c:277: init of variable dicIndexStart
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	STD	-4,U		variable dicIndexStart
* Line lz77.c:277: init of variable dicIndexStop
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	STD	-2,U		variable dicIndexStop
* Line lz77.c:278: while
	LBRA	L00118		jump to while condition
L00117	EQU	*		while body
* Line lz77.c:280: assignment: =
* Line lz77.c:280: conditional expression
	LDD	-6,U		variable index
	SUBD	_dicSize+0,PCR	variable dicSize
	CMPD	#0
	BGE	L00121		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00120 removed
	CLRA
	CLRB
	BRA	L00122		end of true expression of conditional
L00121	EQU	*
	LDD	-6,U		variable index
	SUBD	_dicSize+0,PCR	variable dicSize
L00122	EQU	*
	STD	-4,U
* Line lz77.c:281: assignment: =
	LDD	-6,U		variable index
	ADDD	#$FFFF		65535
	STD	-2,U
* Line lz77.c:284: init of variable t
	CLRA
	CLRB
	STD	-21,U		offset in variable t
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	STD	-19,U		offset in variable t
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	STB	-17,U		offset in variable t
* Line lz77.c:285: assignment: =
* Line lz77.c:285: function call: findInDic()
	LDX	_aheadSize+0,PCR	optim: transformPshsDPshsD
	PSHS	X		optim: transformPshsDPshsD
	LDY	-6,U		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LDX	-2,U		optim: transformPshsDPshsD
	PSHS	Y,X		optim: optimizePshsOps
	LDY	-4,U		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable `input', declared at lz77.c:269
	PSHS	Y,X,B,A		optim: optimizePshsOps
	LEAX	-16,U		address of struct/union to be returned by findInDic()
	PSHS	X		hidden argument
	LBSR	_findInDic
	LEAS	14,S
	LEAX	-16,U		address of struct/union returned by findInDic()
	LDD	#5		size of struct tupleStruct
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-21,U		variable `t', declared at lz77.c:284
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line lz77.c:289: function call: writebits()
	LDB	_dicBitSize+0,PCR	variable `dicBitSize', declared at lz77.c:10
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of writebits(): unsigned char
	LDD	-21,U		member d of tupleStruct, via variable t
	PSHS	B,A		argument 2 of writebits(): unsigned int
	LEAX	-11,U		variable `bf', declared at lz77.c:273
	PSHS	X		argument 1 of writebits(): struct bitFieldStruct *
	LBSR	_writebits
	LEAS	6,S
* Line lz77.c:290: function call: writebits()
	LDB	_aheadBitSize+0,PCR	variable `aheadBitSize', declared at lz77.c:12
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of writebits(): unsigned char
	LDD	-19,U		member l of tupleStruct, via variable t
	PSHS	B,A		argument 2 of writebits(): unsigned int
	LEAX	-11,U		variable `bf', declared at lz77.c:273
	PSHS	X		argument 1 of writebits(): struct bitFieldStruct *
	LBSR	_writebits
	LEAS	6,S
* Line lz77.c:291: function call: writebits()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		argument 3 of writebits(): int
	LDB	-17,U		member c of tupleStruct, via variable t
* optim: stripExtraClrA_B
	PSHS	B,A		argument 2 of writebits(): unsigned char
	LEAX	-11,U		variable `bf', declared at lz77.c:273
	PSHS	X		argument 1 of writebits(): struct bitFieldStruct *
	LBSR	_writebits
	LEAS	6,S
* Line lz77.c:293: assignment: +=
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	CLRA
	LDB	#$01		decimal 1 signed
	ADDD	-19,U		optim: optimizeStackOperations4
	ADDD	-6,U		optim: pushDLoadAdd
* 
* 
	STD	-6,U
L00118	EQU	*		while condition at lz77.c:278
	LDD	-6,U		variable index
	CMPD	6,U		variable iSize
	LBLO	L00117
* optim: branchToNextLocation
* Useless label L00119 removed
* Line lz77.c:295: return with value
	LDD	-9,U		member currentIndex of bitFieldStruct, via variable bf
* Emitted no code to cast `unsigned int' to `int'
* optim: branchToNextLocation
* Useless label L00095 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION compress(): defined at lz77.c:269
funcend_compress	EQU *
funcsize_compress	EQU	funcend_compress-_compress
_computeLPSArray	EXPORT


*******************************************************************************

* FUNCTION computeLPSArray(): defined at lz77.c:172
_computeLPSArray	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-4,S
* Formal parameter(s):
*      4,U:    2 bytes: pattern: unsigned char *
*      6,U:    2 bytes: M: unsigned int
*      8,U:    2 bytes: lps: int *
* Local non-static variable(s):
*     -4,U:    2 bytes: len: int
*     -2,U:    2 bytes: i: int
* Line lz77.c:175: init of variable len
	CLRA
	CLRB
	STD	-4,U		variable len
* Line lz77.c:176: assignment: =
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
* optim: stripUselessPushPull
* optim: optimizeLdx
* optim: stripUselessPushPull
	STD	[8,U]		optim: optimizeLdx
* Line lz77.c:179: init of variable i
* optim: stripExtraClrA_B
	LDB	#$01		1
	STD	-2,U		variable i
* Line lz77.c:180: while
	LBRA	L00124		jump to while condition
L00123	EQU	*		while body
* Line lz77.c:181: if
	LDD	-4,U		variable len
	LDX	4,U		pointer pattern
* optimizeLoadDX
	LDB	D,X		get r-value
	PSHS	B
	LDD	-2,U		variable i
	LDX	4,U		pointer pattern
* optimizeLoadDX
	LDB	D,X		get r-value
	CMPB	,S+		compare with LSB
	BNE	L00127		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00126 removed
* Line lz77.c:181
* Line lz77.c:182: post-increment
	LDX	-4,U		variable `len', declared at lz77.c:182
	LEAX	1,X
	STX	-4,U
* Line lz77.c:183: assignment: =
	LDD	-4,U		variable `len', declared at lz77.c:175
	PSHS	B,A
	LDD	-2,U		variable i
	LSLB
	ROLA
	LDX	8,U		pointer lps
	LEAX	D,X		add offset
	PULS	A,B		retrieve value to store
	STD	,X
* Line lz77.c:184: post-increment
	LDX	-2,U		variable `i', declared at lz77.c:184
	LEAX	1,X
	STX	-2,U
	BRA	L00128		jump over else clause
L00127	EQU	*		else clause of if() started at lz77.c:181
* Line lz77.c:185
* Line lz77.c:189: if
	LDD	-4,U		variable `len', declared at lz77.c:175
* optim: loadCmpZeroBeqOrBne
	BEQ	L00130		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00129 removed
* Line lz77.c:189
* Line lz77.c:190: assignment: =
	LDD	-4,U		variable len
	ADDD	#$FFFF		65535
	LSLB
	ROLA
	LDX	8,U		pointer lps
* optimizeLoadDX
	LDD	D,X		get r-value
	STD	-4,U
	BRA	L00131		jump over else clause
L00130	EQU	*		else clause of if() started at lz77.c:189
* Line lz77.c:194
* Line lz77.c:195: assignment: =
	CLRA
	CLRB
	PSHS	B,A
	LDD	-2,U		variable i
	LSLB
	ROLA
	LDX	8,U		pointer lps
	LEAX	D,X		add offset
	PULS	A,B		retrieve value to store
	STD	,X
* Line lz77.c:196: post-increment
	LDX	-2,U		variable `i', declared at lz77.c:196
	LEAX	1,X
	STX	-2,U
L00131	EQU	*		end of if() started at lz77.c:189
L00128	EQU	*		end of if() started at lz77.c:181
L00124	EQU	*		while condition at lz77.c:180
	LDD	-2,U		variable i
	CMPD	6,U		variable M
	LBLO	L00123
* optim: branchToNextLocation
* Useless label L00125 removed
* Useless label L00092 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION computeLPSArray(): defined at lz77.c:172
funcend_computeLPSArray	EQU *
funcsize_computeLPSArray	EQU	funcend_computeLPSArray-_computeLPSArray
_delay	IMPORT
_divdwb	IMPORT
_divdww	IMPORT
_divmod16	IMPORT
_divmod8	IMPORT
_dwtoa	IMPORT
_enableCMOCFloatSupport	IMPORT
_exit	IMPORT
_findInDic	EXPORT


*******************************************************************************

* FUNCTION findInDic(): defined at lz77.c:240
_findInDic	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-14,S
* Formal parameter(s):
*      6,U:    2 bytes: input: unsigned char *
*      8,U:    2 bytes: inputSize: unsigned int
*     10,U:    2 bytes: startDicIndex: unsigned int
*     12,U:    2 bytes: stopDicIndex: unsigned int
*     14,U:    2 bytes: startAHead: unsigned int
*     16,U:    2 bytes: aHeadSize: unsigned int
* Local non-static variable(s):
*    -11,U:    2 bytes: i: unsigned int
*     -9,U:    5 bytes: t: struct tupleStruct
*     -4,U:    2 bytes: match: int
*     -2,U:    2 bytes: maxAHeadIndex: unsigned int
* Line lz77.c:243: if
	LDD	14,U		variable startAHead
	CMPD	10,U		variable startDicIndex
	BEQ	L00132
* optim: branchToNextLocation
* Useless label L00134 removed
	LDD	10,U		variable startDicIndex
	CMPD	12,U		variable stopDicIndex
	BNE	L00133		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
L00132	EQU	*		then clause of if() started at lz77.c:243
* Line lz77.c:243
* Line lz77.c:245: init of variable t
	CLRA
	CLRB
	STD	-14,U		offset in variable t
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	STD	-12,U		offset in variable t
	LDD	14,U		variable startAHead
	LDX	6,U		pointer input
* optimizeLoadDX
	LDB	D,X		get r-value
	STB	-10,U		offset in variable t
* Line lz77.c:246: return struct/union by value
	LEAX	-14,U		variable `t', declared at lz77.c:245
	PSHS	X		source struct/union
	LDX	4,U		address of return value
	LDD	#5		size of struct tupleStruct
	LBSR	copyMem
	LEAS	2,S		discard copyMem argument
	LBRA	L00094		return (lz77.c:246)
L00133	EQU	*		else clause of if() started at lz77.c:243
* Useless label L00135 removed
* Line lz77.c:249: init of variable t
	CLRA
	CLRB
	STD	-9,U		offset in variable t
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	STD	-7,U		offset in variable t
	LDD	14,U		variable startAHead
	LDX	6,U		pointer input
* optimizeLoadDX
	LDB	D,X		get r-value
	STB	-5,U		offset in variable t
* Line lz77.c:250: init of variable match
	LDD	#$FFFF		65535
	STD	-4,U		variable match
* Line lz77.c:253: init of variable maxAHeadIndex
* Line lz77.c:253: conditional expression
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDD	14,U		variable startAHead
	ADDD	_aheadSize+0,PCR	variable aheadSize
	CMPD	8,U		optim: optimizeStackOperations4
	BLS	L00137		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00136 removed
* optim: stripOpToDeadReg
* optim: stripOpToDeadReg
* PSHS B,A optim: optimizeStackOperations1
	LDD	8,U		variable inputSize
	SUBD	14,U		variable startAHead
	SUBD	#1		optim: optimizeStackOperations1
	BRA	L00138		end of true expression of conditional
L00137	EQU	*
	LDD	16,U		variable aHeadSize
	ADDD	#$FFFF		65535
L00138	EQU	*
	STD	-2,U		variable maxAHeadIndex
* Line lz77.c:255: for init
* Line lz77.c:255: init of variable i
* optim: storeLoad
	STD	-11,U		variable i
	BRA	L00140		jump to for condition
L00139	EQU	*
* Line lz77.c:255: for body
* Line lz77.c:256: assignment: =
* Line lz77.c:256: function call: knuthMorrisPrattSearch()
	LDD	12,U		variable stopDicIndex
	SUBD	10,U		variable startDicIndex
	PSHS	B,A		argument 4 of knuthMorrisPrattSearch(): unsigned int
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDD	6,U		variable `input', declared at lz77.c:240
	ADDD	10,U		optim: optimizeStackOperations4
	PSHS	B,A		argument 3 of knuthMorrisPrattSearch(): unsigned char *
	LDD	-11,U		variable `i', declared at lz77.c:255
	PSHS	B,A		argument 2 of knuthMorrisPrattSearch(): unsigned int
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDD	6,U		variable `input', declared at lz77.c:240
	ADDD	14,U		optim: optimizeStackOperations4
	PSHS	B,A		argument 1 of knuthMorrisPrattSearch(): unsigned char *
	LBSR	_knuthMorrisPrattSearch
	LEAS	8,S
	STD	-4,U
* Line lz77.c:257: if
* optim: storeLoad
	ADDD	#0
	BLT	L00144		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00143 removed
* Line lz77.c:257
* Line lz77.c:258: assignment: =
* optim: optimize16BitStackOps1
* optim: optimize16BitStackOps1
* optim: stripOpToDeadReg
* optim: stripOpToDeadReg
* PSHS B,A optim: optimizeStackOperations1
	LDD	12,U		variable stopDicIndex
	SUBD	10,U		variable startDicIndex
	ADDD	#1		optim: optimizeStackOperations1
	SUBD	-4,U		optim: optimize16BitStackOps1
* optim: stripUselessPushPull
* optim: optimizeLeax
* optim: stripUselessPushPull
	STD	-9,U		optim: optimizeLeax
* Line lz77.c:259: assignment: =
	LDD	-11,U		variable `i', declared at lz77.c:255
* optim: stripUselessPushPull
* optim: optimizeLeax
* optim: stripUselessPushPull
	STD	-7,U		optim: optimizeLeax
* Line lz77.c:260: assignment: =
	LDD	14,U		variable startAHead
	ADDD	-11,U		variable i
	LDX	6,U		pointer input
* optimizeLoadDX
	LDB	D,X		get r-value
* optim: stripExtraPushPullB
* optim: optimizeLeax
* optim: stripExtraPushPullB
	STB	-5,U		optim: optimizeLeax
	BRA	L00142		break
L00144	EQU	*		else clause of if() started at lz77.c:257
* Useless label L00145 removed
* Useless label L00141 removed
* Line lz77.c:255: for increment(s)
	LDD	-11,U
	SUBD	#1
	STD	-11,U
L00140	EQU	*
* Line lz77.c:255: for condition
	LDD	-11,U		variable i
	CMPD	#$01
	BHS	L00139
* optim: branchToNextLocation
L00142	EQU	*		end for
* Line lz77.c:265: return struct/union by value
	LEAX	-9,U		variable `t', declared at lz77.c:249
	PSHS	X		source struct/union
	LDX	4,U		address of return value
	LDD	#5		size of struct tupleStruct
	LBSR	copyMem
	LEAS	2,S		discard copyMem argument
* optim: branchToNextLocation
L00094	EQU	*		end of findInDic()
	LEAS	,U
	PULS	U,PC
* END FUNCTION findInDic(): defined at lz77.c:240
funcend_findInDic	EQU *
funcsize_findInDic	EQU	funcend_findInDic-_findInDic
_initBitField	EXPORT


*******************************************************************************

* FUNCTION initBitField(): defined at lz77.c:35
_initBitField	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
* Formal parameter(s):
*      4,U:    2 bytes: bf: struct bitFieldStruct *
*      6,U:    2 bytes: buf: unsigned char *
* Line lz77.c:37: assignment: =
	CLRA
	LDB	#$07		decimal 7 signed
* optim: stripExtraPushPullB
	LDX	4,U		variable bf
* optim: optimizeLeax
* optim: stripExtraPushPullB
	STB	4,X		optim: optimizeLeax
* Line lz77.c:38: assignment: =
* optim: stripExtraClrA_B
	CLRB
* optim: stripUselessPushPull
	LDX	4,U		variable bf
* optim: optimizeLeax
* optim: stripUselessPushPull
	STD	2,X		optim: optimizeLeax
* Line lz77.c:39: assignment: =
	LDD	6,U		variable `buf', declared at lz77.c:35
* optim: stripUselessPushPull
* optim: optimizeLdx
* optim: stripUselessPushPull
	STD	[4,U]		optim: optimizeLdx
* Useless label L00086 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION initBitField(): defined at lz77.c:35
funcend_initBitField	EQU *
funcsize_initBitField	EQU	funcend_initBitField-_initBitField
_initDefaultParameters	EXPORT


*******************************************************************************

* FUNCTION initDefaultParameters(): defined at lz77.c:17
_initDefaultParameters	EQU	*
* Calling convention: Default
* Line lz77.c:19: assignment: =
	LDD	#$0FFF		decimal 4095 signed
	STD	_dicSize+0,PCR
* Line lz77.c:20: assignment: =
	LDB	#$0C
	STB	_dicBitSize+0,PCR	variable dicBitSize
* Line lz77.c:21: assignment: =
	CLRA
	LDB	#$3F		decimal 63 signed
	STD	_aheadSize+0,PCR
* Line lz77.c:22: assignment: =
	LDB	#$06
	STB	_aheadBitSize+0,PCR	variable aheadBitSize
* Line lz77.c:23: function call: memset()
	LDB	#$3F		optim: removeAndOrMulAddSub
	PSHS	B,A		argument 3 of memset(): int
* optim: removeClr
	CLRB
	PSHS	B,A		argument 2 of memset(): int
	LEAX	_lps+0,PCR	address of array lps
	PSHS	X		argument 1 of memset(): int[]
	LBSR	_memset
	LEAS	6,S
* Useless label L00084 removed
	RTS
* END FUNCTION initDefaultParameters(): defined at lz77.c:17
funcend_initDefaultParameters	EQU *
funcsize_initDefaultParameters	EQU	funcend_initDefaultParameters-_initDefaultParameters
_initParameters	EXPORT


*******************************************************************************

* FUNCTION initParameters(): defined at lz77.c:26
_initParameters	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
* Formal parameter(s):
*      4,U:    2 bytes: dsz: unsigned int
*      7,U:    1 byte : bdsz: unsigned char
*      8,U:    2 bytes: asz: unsigned int
*     11,U:    1 byte : basz: unsigned char
* Line lz77.c:28: assignment: =
* optim: stripConsecutiveLoadsToSameReg
	LDD	4,U
	STD	_dicSize+0,PCR
* Line lz77.c:29: assignment: =
	LDB	7,U		variable `bdsz', declared at lz77.c:26
	STB	_dicBitSize+0,PCR
* Line lz77.c:30: assignment: =
* optim: stripConsecutiveLoadsToSameReg
	LDD	8,U
	STD	_aheadSize+0,PCR
* Line lz77.c:31: assignment: =
	LDB	11,U		variable `basz', declared at lz77.c:26
	STB	_aheadBitSize+0,PCR
* Line lz77.c:32: function call: memset()
	CLRA
	LDB	#$3F		decimal 63 signed
	PSHS	B,A		argument 3 of memset(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		argument 2 of memset(): int
	LEAX	_lps+0,PCR	address of array lps
	PSHS	X		argument 1 of memset(): int[]
	LBSR	_memset
	LEAS	6,S
* Useless label L00085 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION initParameters(): defined at lz77.c:26
funcend_initParameters	EQU *
funcsize_initParameters	EQU	funcend_initParameters-_initParameters
_isalnum	IMPORT
_isalpha	IMPORT
_isdigit	IMPORT
_isspace	IMPORT
_itoa10	IMPORT
_karpRabinSearch	EXPORT


*******************************************************************************

* FUNCTION karpRabinSearch(): defined at lz77.c:132
_karpRabinSearch	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-10,S
* Formal parameter(s):
*      4,U:    2 bytes: x: unsigned char *
*      6,U:    2 bytes: m: int
*      8,U:    2 bytes: y: unsigned char *
*     10,U:    2 bytes: n: int
* Local non-static variable(s):
*    -10,U:    2 bytes: d: int
*     -8,U:    2 bytes: hx: int
*     -6,U:    2 bytes: hy: int
*     -4,U:    2 bytes: i: int
*     -2,U:    2 bytes: j: int
* Line lz77.c:145: for init
* Line lz77.c:145: assignment: =
* Line lz77.c:145: assignment: =
	CLRA
	LDB	#$01		decimal 1 signed
	STD	-4,U
	STD	-10,U
	BRA	L00147		jump to for condition
L00146	EQU	*
* Line lz77.c:146: for body
* Line lz77.c:146: assignment: =
	LDD	-10,U		variable `d', declared at lz77.c:136
	LSLB
	ROLA
	STD	-10,U
* Useless label L00148 removed
* Line lz77.c:145: for increment(s)
	LDD	-4,U
	ADDD	#1
	STD	-4,U
L00147	EQU	*
* Line lz77.c:145: for condition
	LDD	-4,U		variable i
	CMPD	6,U		variable m
	BLT	L00146
* optim: branchToNextLocation
* Useless label L00149 removed
* Line lz77.c:148: for init
* Line lz77.c:148: assignment: =
* Line lz77.c:148: assignment: =
* Line lz77.c:148: assignment: =
	CLRA
	CLRB
	STD	-4,U
	STD	-8,U
	STD	-6,U
	BRA	L00151		jump to for condition
L00150	EQU	*
* Line lz77.c:148: for body
* Line lz77.c:149: assignment: =
	LDD	-4,U		variable i
	LDX	4,U		pointer x
* optimizeLoadDX
	LDB	D,X		get r-value
	CLRA			promotion of binary operand
	PSHS	B,A
	LDD	-8,U		variable `hx', declared at lz77.c:136
	LSLB
	ROLA
	ADDD	,S++
	STD	-8,U
* Line lz77.c:150: assignment: =
	LDD	-4,U		variable i
	LDX	8,U		pointer y
* optimizeLoadDX
	LDB	D,X		get r-value
	CLRA			promotion of binary operand
	PSHS	B,A
	LDD	-6,U		variable `hy', declared at lz77.c:136
	LSLB
	ROLA
	ADDD	,S++
	STD	-6,U
* Useless label L00152 removed
* Line lz77.c:148: for increment(s)
	LDD	-4,U
	ADDD	#1
	STD	-4,U
L00151	EQU	*
* Line lz77.c:148: for condition
	LDD	-4,U		variable i
	CMPD	6,U		variable m
	BLT	L00150
* optim: branchToNextLocation
* Useless label L00153 removed
* Line lz77.c:154: assignment: =
	CLRA
	CLRB
	STD	-2,U
* Line lz77.c:155: while
	LBRA	L00155		jump to while condition
L00154	EQU	*		while body
* Line lz77.c:156: if
	LDD	-8,U		variable hx
	CMPD	-6,U		variable hy
	BNE	L00158		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00159 removed
* Line lz77.c:156: function call: memcmp()
	LDD	6,U		variable `m', declared at lz77.c:132
	PSHS	B,A		argument 3 of memcmp(): int
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDD	8,U		variable `y', declared at lz77.c:132
	ADDD	-2,U		optim: optimizeStackOperations4
	PSHS	B,A		argument 2 of memcmp(): unsigned char *
	LDD	4,U		variable `x', declared at lz77.c:132
	PSHS	B,A		argument 1 of memcmp(): unsigned char *
	LBSR	_memcmp
	LEAS	6,S
	ADDD	#0
	BNE	L00158		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00157 removed
* Line lz77.c:157
* Line lz77.c:157: return with value
	LDD	-2,U		variable `j', declared at lz77.c:136
	BRA	L00091		return (lz77.c:157)
L00158	EQU	*		else clause of if() started at lz77.c:156
* Useless label L00160 removed
* Line lz77.c:158: assignment: =
	LDD	-2,U		variable j
	ADDD	6,U		variable m
	LDX	8,U		pointer y
* optimizeLoadDX
	LDB	D,X		get r-value
	CLRA			promotion of binary operand
	PSHS	B,A
	LDD	-2,U		variable j
	LDX	8,U		pointer y
* optimizeLoadDX
	LDB	D,X		get r-value
	CLRA			promotion of binary operand
	TFR	D,X		optim: stripExtraPulsX
	LDD	-10,U		variable `d', declared at lz77.c:136
* optim: stripExtraPulsX
	LBSR	MUL16
	PSHS	B,A
	LDD	-6,U		variable `hy', declared at lz77.c:136
	SUBD	,S++
	LSLB
	ROLA
	ADDD	,S++
	STD	-6,U
* Line lz77.c:159: pre-increment
	LDX	-2,U		variable `j', declared at lz77.c:159
	LEAX	1,X
	STX	-2,U
L00155	EQU	*		while condition at lz77.c:155
	LDD	10,U		variable n
	SUBD	6,U		variable m
* optim: optimize16BitCompares
* optim: optimize16BitCompares
	CMPD	-2,U		optim: optimize16BitCompares
	LBGE	L00154		optim: optimize16BitCompares
* optim: branchToNextLocation
* Useless label L00156 removed
* Line lz77.c:161: return with value
	LDD	#$FFFF		constant expression: 65535 decimal, signed
* optim: branchToNextLocation
L00091	EQU	*		end of karpRabinSearch()
	LEAS	,U
	PULS	U,PC
* END FUNCTION karpRabinSearch(): defined at lz77.c:132
funcend_karpRabinSearch	EQU *
funcsize_karpRabinSearch	EQU	funcend_karpRabinSearch-_karpRabinSearch
_knuthMorrisPrattSearch	EXPORT


*******************************************************************************

* FUNCTION knuthMorrisPrattSearch(): defined at lz77.c:203
_knuthMorrisPrattSearch	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-4,S
* Formal parameter(s):
*      4,U:    2 bytes: x: unsigned char *
*      6,U:    2 bytes: m: int
*      8,U:    2 bytes: y: unsigned char *
*     10,U:    2 bytes: n: int
* Local non-static variable(s):
*     -4,U:    2 bytes: i: unsigned int
*     -2,U:    2 bytes: j: unsigned int
* Line lz77.c:206: function call: computeLPSArray()
	LEAX	_lps+0,PCR	address of array lps
* optim: optimizePshsOps
	LDD	6,U		variable `m', declared at lz77.c:203
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	4,U		variable `x', declared at lz77.c:203
	PSHS	B,A		argument 1 of computeLPSArray(): unsigned char *
	LBSR	_computeLPSArray
	LEAS	6,S
* Line lz77.c:208: init of variable i
	CLRA
	CLRB
	STD	-4,U		variable i
* Line lz77.c:209: init of variable j
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	STD	-2,U		variable j
* Line lz77.c:210: while
	LBRA	L00162		jump to while condition
L00161	EQU	*		while body
* Line lz77.c:211: if
	LDD	-4,U		variable i
	LDX	8,U		pointer y
* optimizeLoadDX
	LDB	D,X		get r-value
	PSHS	B
	LDD	-2,U		variable j
	LDX	4,U		pointer x
* optimizeLoadDX
	LDB	D,X		get r-value
	CMPB	,S+		compare with LSB
	BNE	L00165		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00164 removed
* Line lz77.c:211
* Line lz77.c:212: post-increment
	LDX	-2,U		variable `j', declared at lz77.c:212
	LEAX	1,X
	STX	-2,U
* Line lz77.c:213: post-increment
	LDX	-4,U		variable `i', declared at lz77.c:213
	LEAX	1,X
	STX	-4,U
L00165	EQU	*		else clause of if() started at lz77.c:211
* Useless label L00166 removed
* Line lz77.c:216: if
	LDD	-2,U		variable j
	CMPD	6,U		variable m
	BNE	L00168		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00167 removed
* Line lz77.c:216
* Line lz77.c:218: return with value
	LDD	-4,U		variable i
	SUBD	-2,U		variable j
* Emitted no code to cast `unsigned int' to `int'
	BRA	L00093		return (lz77.c:218)
* optim: instrFollowingUncondBranch
L00168	EQU	*		else clause of if() started at lz77.c:216
* Line lz77.c:234
* Line lz77.c:223: if
	LDD	-4,U		variable i
	CMPD	10,U		variable n
	BHS	L00171		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00172 removed
	LDD	-4,U		variable i
	LDX	8,U		pointer y
* optimizeLoadDX
	LDB	D,X		get r-value
	PSHS	B
	LDD	-2,U		variable j
	LDX	4,U		pointer x
* optimizeLoadDX
	LDB	D,X		get r-value
	CMPB	,S+		compare with LSB
	BEQ	L00171		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00170 removed
* Line lz77.c:223
* Line lz77.c:226: if
	LDD	-2,U		variable `j', declared at lz77.c:209
* optim: loadCmpZeroBeqOrBne
	BEQ	L00174		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00173 removed
* Line lz77.c:226
* Line lz77.c:228: assignment: =
	LDD	-2,U		variable j
	ADDD	#$FFFF		65535
	LSLB
	ROLA
	LEAX	_lps+0,PCR	address of array lps
* optimizeLoadDX
	LDD	D,X		get r-value
	STD	-2,U
	BRA	L00175		jump over else clause
L00174	EQU	*		else clause of if() started at lz77.c:226
* Line lz77.c:229
* Line lz77.c:231: assignment: =
	LDD	-4,U		variable i
	ADDD	#$01		1
	STD	-4,U
L00175	EQU	*		end of if() started at lz77.c:226
L00171	EQU	*		else clause of if() started at lz77.c:223
* Useless label L00176 removed
* Useless label L00169 removed
L00162	EQU	*		while condition at lz77.c:210
	LDD	6,U		variable m
	SUBD	-2,U		variable j
	PSHS	B,A
	LDD	10,U		variable n
	SUBD	-4,U		variable i
	CMPD	,S++
	LBGE	L00161
* optim: branchToNextLocation
* Useless label L00163 removed
* Line lz77.c:235: return with value
	LDD	#$FFFF		constant expression: 65535 decimal, signed
* optim: branchToNextLocation
L00093	EQU	*		end of knuthMorrisPrattSearch()
	LEAS	,U
	PULS	U,PC
* END FUNCTION knuthMorrisPrattSearch(): defined at lz77.c:203
funcend_knuthMorrisPrattSearch	EQU *
funcsize_knuthMorrisPrattSearch	EQU	funcend_knuthMorrisPrattSearch-_knuthMorrisPrattSearch
_labs	IMPORT
_ltoa10	IMPORT
_memchr	IMPORT
_memcmp	IMPORT
_memcpy	IMPORT
_memichr	IMPORT
_memicmp	IMPORT
_memmove	IMPORT
_memset	IMPORT
_memset16	IMPORT
_mulwb	IMPORT
_mulww	IMPORT
_printf	IMPORT
_putchar	IMPORT
_putstr	IMPORT
_qsort	IMPORT
_rand	IMPORT
_readbits	EXPORT


*******************************************************************************

* FUNCTION readbits(): defined at lz77.c:68
_readbits	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-6,S
* Formal parameter(s):
*      4,U:    2 bytes: bf: struct bitFieldStruct *
*      7,U:    1 byte : bitCount: unsigned char
* Local non-static variable(s):
*     -6,U:    1 byte : mask: unsigned char
*     -5,U:    2 bytes: value: unsigned int
*     -3,U:    2 bytes: currentBit: unsigned int
*     -1,U:    1 byte : bitSet: unsigned char
* Line lz77.c:71: init of variable mask
	CLR	-6,U		variable mask
* Line lz77.c:72: init of variable value
	CLRA
	CLRB
	STD	-5,U		variable value
* Line lz77.c:73: init of variable currentBit
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	STD	-3,U		variable currentBit
* Line lz77.c:74: init of variable bitSet
	CLR	-1,U		variable bitSet
* Line lz77.c:75: while
	LBRA	L00178		jump to while condition
L00177	EQU	*		while body
* Line lz77.c:76: assignment: =
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		left side of shift: used and popped by shiftLeft
	LDX	4,U		variable bf
	LDB	4,X		member bitLeft of bitFieldStruct
* optim: stripExtraClrA_B
	LBSR	shiftLeft
* Cast from `int' to byte: result already in B
	STB	-6,U
* Line lz77.c:77: assignment: =
* optim: storeLoad
	PSHS	B
	LDX	4,U		variable bf
	LDD	2,X		member currentIndex of bitFieldStruct
	PSHS	B,A		preserve array index
	LDX	4,U		variable bf
	LDD	,X		member buffer of bitFieldStruct
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,X		get r-value
	ANDB	,S+
	PSHS	B		left side of shift: used and popped by shiftByteRightUnsigned
	LDX	4,U		variable bf
	LDB	4,X		member bitLeft of bitFieldStruct
	CLRA
	LBSR	shiftByteRightUnsigned
	CLRA
	STD	-3,U
* Line lz77.c:78: assignment: |=
* optim: storeLoad
	PSHS	B,A		left side of shift: used and popped by shiftLeft
	LDB	-1,U		variable `bitSet', declared at lz77.c:74
* optim: stripExtraClrA_B
	LBSR	shiftLeft
	PSHS	B,A
	LEAX	-5,U
	LDD	,S++
	ORA	,X
	ORB	1,X
	STD	,X
* Line lz77.c:79: post-decrement
	DEC	7,U
* Line lz77.c:80: post-increment
	INC	-1,U
* Line lz77.c:81: post-decrement
	LDX	4,U		variable bf
* optim: optimizeLeax
	DEC	4,X		optim: optimizeLeax
* Line lz77.c:82: if
	LDX	4,U		variable bf
	LDB	4,X		member bitLeft of bitFieldStruct
	CMPB	#0
	BGE	L00181		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00180 removed
* Line lz77.c:82
* Line lz77.c:83: assignment: =
	CLRA
* LDB #$07 optim: optimizeStackOperations1
* PSHS B optim: optimizeStackOperations1
	LDX	4,U		variable bf
* optim: optimizeLeax
	LDB	#7		optim: optimizeStackOperations1
	STB	4,X		optim: optimizeLeax
* Line lz77.c:84: post-increment
	LDX	4,U		variable bf
	LEAX	2,X		member currentIndex of bitFieldStruct
	LDD	,X
	ADDD	#1
	STD	,X
L00181	EQU	*		else clause of if() started at lz77.c:82
* Useless label L00182 removed
L00178	EQU	*		while condition at lz77.c:75
	LDB	7,U		variable `bitCount', declared at lz77.c:68
* optim: loadCmpZeroBeqOrBne
	LBNE	L00177
* optim: branchToNextLocation
* Useless label L00179 removed
* Line lz77.c:87: return with value
	LDD	-5,U		variable `value', declared at lz77.c:72
* optim: branchToNextLocation
* Useless label L00088 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION readbits(): defined at lz77.c:68
funcend_readbits	EQU *
funcsize_readbits	EQU	funcend_readbits-_readbits
_readline	IMPORT
_readword	IMPORT
_sbrk	IMPORT
_sbrkmax	IMPORT
_setConsoleOutHook	IMPORT
_set_null_ptr_handler	IMPORT
_set_stack_overflow_handler	IMPORT
_sprintf	IMPORT
_sqrt16	IMPORT
_sqrt32	IMPORT
_srand	IMPORT
_strcat	IMPORT
_strchr	IMPORT
_strcmp	IMPORT
_strcpy	IMPORT
_stricmp	IMPORT
_strlen	IMPORT
_strlwr	IMPORT
_strncmp	IMPORT
_strncpy	IMPORT
_strstr	IMPORT
_strtol	IMPORT
_strtoul	IMPORT
_strupr	IMPORT
_subdww	IMPORT
_tolower	IMPORT
_toupper	IMPORT
_ultoa10	IMPORT
_uncompress	EXPORT


*******************************************************************************

* FUNCTION uncompress(): defined at lz77.c:299
_uncompress	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-12,S
* Formal parameter(s):
*      4,U:    2 bytes: input: unsigned char *
*      6,U:    2 bytes: iSize: unsigned int
*      8,U:    2 bytes: output: unsigned char *
*     10,U:    2 bytes: oSize: unsigned int
* Local non-static variable(s):
*    -12,U:    5 bytes: t: struct tupleStruct
*     -7,U:    5 bytes: bf: struct bitFieldStruct
*     -2,U:    2 bytes: outputIdx: int
* Line lz77.c:302: function call: initBitField()
	LDD	4,U		variable `input', declared at lz77.c:299
	PSHS	B,A		argument 2 of initBitField(): unsigned char *
	LEAX	-7,U		variable `bf', declared at lz77.c:301
	PSHS	X		argument 1 of initBitField(): struct bitFieldStruct *
	LBSR	_initBitField
	LEAS	4,S
* Line lz77.c:303: init of variable outputIdx
	CLRA
	CLRB
	STD	-2,U		variable outputIdx
* Line lz77.c:304: function call: memset()
	LDD	10,U		variable `oSize', declared at lz77.c:299
	PSHS	B,A		argument 3 of memset(): unsigned int
	CLRA
	CLRB
	PSHS	B,A		argument 2 of memset(): int
	LDD	8,U		variable `output', declared at lz77.c:299
	PSHS	B,A		argument 1 of memset(): unsigned char *
	LBSR	_memset
	LEAS	6,S
* Line lz77.c:306: while
	LBRA	L00184		jump to while condition
L00183	EQU	*		while body
* Line lz77.c:309: assignment: =
* Line lz77.c:309: function call: readbits()
	LDB	_dicBitSize+0,PCR	variable `dicBitSize', declared at lz77.c:10
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of readbits(): unsigned char
	LEAX	-7,U		variable `bf', declared at lz77.c:301
	PSHS	X		argument 1 of readbits(): struct bitFieldStruct *
	LBSR	_readbits
	LEAS	4,S
* optim: stripUselessPushPull
* optim: optimizeLeax
* optim: stripUselessPushPull
	STD	-12,U		optim: optimizeLeax
* Line lz77.c:310: assignment: =
* Line lz77.c:310: function call: readbits()
	LDB	_aheadBitSize+0,PCR	variable `aheadBitSize', declared at lz77.c:12
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of readbits(): unsigned char
	LEAX	-7,U		variable `bf', declared at lz77.c:301
	PSHS	X		argument 1 of readbits(): struct bitFieldStruct *
	LBSR	_readbits
	LEAS	4,S
* optim: stripUselessPushPull
* optim: optimizeLeax
* optim: stripUselessPushPull
	STD	-10,U		optim: optimizeLeax
* Line lz77.c:311: assignment: =
* Line lz77.c:311: function call: readbits()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		argument 2 of readbits(): int
	LEAX	-7,U		variable `bf', declared at lz77.c:301
	PSHS	X		argument 1 of readbits(): struct bitFieldStruct *
	LBSR	_readbits
	LEAS	4,S
* Cast from `unsigned int' to byte: result already in B
* optim: stripExtraPushPullB
* optim: optimizeLeax
* optim: stripExtraPushPullB
	STB	-8,U		optim: optimizeLeax
* Line lz77.c:314: if
	LDD	-12,U		member d of tupleStruct, via variable t
* optim: loadCmpZeroBeqOrBne
	BEQ	L00187		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00186 removed
* Line lz77.c:314
* Line lz77.c:316: function call: memcpy()
	LDD	-10,U		member l of tupleStruct, via variable t
	PSHS	B,A		argument 3 of memcpy(): unsigned int
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDD	8,U		variable `output', declared at lz77.c:299
	ADDD	-2,U		optim: optimizeStackOperations4
	SUBD	-12,U		optim: optimizeStackOperations4
	PSHS	B,A		argument 2 of memcpy(): unsigned char *
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDD	8,U		variable `output', declared at lz77.c:299
	ADDD	-2,U		optim: optimizeStackOperations4
	PSHS	B,A		argument 1 of memcpy(): unsigned char *
	LBSR	_memcpy
	LEAS	6,S
* Line lz77.c:317: assignment: +=
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDD	-2,U
	ADDD	-10,U		optim: optimizeStackOperations4
	STD	-2,U
L00187	EQU	*		else clause of if() started at lz77.c:314
* Useless label L00188 removed
* Line lz77.c:320: assignment: =
	LDB	-8,U		member c of tupleStruct, via variable t
	PSHS	B
	LDD	-2,U		variable `outputIdx', declared at lz77.c:320
	ADDD	#1
	STD	-2,U
	SUBD	#1		post increment yields initial value
	LDX	8,U		pointer output
	LEAX	D,X		add offset
	LDB	,S+
	STB	,X
L00184	EQU	*		while condition at lz77.c:306
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDD	-5,U		member currentIndex of bitFieldStruct, via variable bf
	CMPD	6,U		optim: optimizeStackOperations4
	LBLO	L00183
* optim: branchToNextLocation
* Useless label L00185 removed
* Line lz77.c:322: return with value
	LDD	-2,U		variable `outputIdx', declared at lz77.c:303
* optim: branchToNextLocation
* Useless label L00096 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION uncompress(): defined at lz77.c:299
funcend_uncompress	EQU *
funcsize_uncompress	EQU	funcend_uncompress-_uncompress
_utoa10	IMPORT
_vprintf	IMPORT
_vsprintf	IMPORT
_writebits	EXPORT


*******************************************************************************

* FUNCTION writebits(): defined at lz77.c:42
_writebits	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-2,S
* Formal parameter(s):
*      4,U:    2 bytes: bf: struct bitFieldStruct *
*      6,U:    2 bytes: value: unsigned int
*      9,U:    1 byte : bitCount: unsigned char
* Local non-static variable(s):
*     -2,U:    1 byte : i: unsigned char
*     -1,U:    1 byte : bitSet: unsigned char
* Line lz77.c:46: init of variable bitSet
	CLR	-1,U		variable bitSet
* Line lz77.c:47: while
	LBRA	L00190		jump to while condition
L00189	EQU	*		while body
* Line lz77.c:48: init of variable currentBit
	LDD	6,U		variable value
	CLRA			optim: andA_B0
	ANDB	#$01
* Cast from `unsigned int' to byte: result already in B
	STB	-2,U		variable currentBit
* Line lz77.c:49: assignment: |=
* optim: storeLoad
	PSHS	B		left side of shift: used and popped by shiftByteLeft
	LDX	4,U		variable bf
	LDB	4,X		member bitLeft of bitFieldStruct
* optim: stripExtraClrA_B
	LBSR	shiftByteLeft
	PSHS	B
	LDX	4,U		variable bf
	LDD	2,X		member currentIndex of bitFieldStruct
	PSHS	B,A		preserve array index
	LDX	4,U		variable bf
	LDD	,X		member buffer of bitFieldStruct
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,X
	ORB	,S+
	STB	,X
* Line lz77.c:50: post-decrement
	LDX	4,U		variable bf
* optim: optimizeLeax
	DEC	4,X		optim: optimizeLeax
* Line lz77.c:51: if
	LDX	4,U		variable bf
	LDB	4,X		member bitLeft of bitFieldStruct
	CMPB	#0
	BGE	L00193		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00192 removed
* Line lz77.c:51
* Line lz77.c:52: assignment: =
	CLRA
* LDB #$07 optim: optimizeStackOperations1
* PSHS B optim: optimizeStackOperations1
	LDX	4,U		variable bf
* optim: optimizeLeax
	LDB	#7		optim: optimizeStackOperations1
	STB	4,X		optim: optimizeLeax
* Line lz77.c:53: post-increment
	LDX	4,U		variable bf
	LEAX	2,X		member currentIndex of bitFieldStruct
	LDD	,X
	ADDD	#1
	STD	,X
L00193	EQU	*		else clause of if() started at lz77.c:51
* Useless label L00194 removed
* Line lz77.c:55: post-increment
	INC	-1,U
* Line lz77.c:56: assignment: =
	LDD	6,U		variable `value', declared at lz77.c:42
	LSRA
	RORB
	STD	6,U
L00190	EQU	*		while condition at lz77.c:47
	LDD	6,U		variable `value', declared at lz77.c:42
* optim: loadCmpZeroBeqOrBne
	LBNE	L00189
* optim: branchToNextLocation
* Useless label L00191 removed
* Line lz77.c:58: for init
* Line lz77.c:58: init of variable i
	CLR	-2,U		variable i
	BRA	L00196		jump to for condition
L00195	EQU	*
* Line lz77.c:58: for body
* Line lz77.c:59: assignment: |=
	CLRA
	CLRB
	PSHS	B,A		left side of shift: used and popped by shiftLeft
	LDX	4,U		variable bf
	LDB	4,X		member bitLeft of bitFieldStruct
* optim: stripExtraClrA_B
	LBSR	shiftLeft
* Cast from `int' to byte: result already in B
	PSHS	B
	LDX	4,U		variable bf
	LDD	2,X		member currentIndex of bitFieldStruct
	PSHS	B,A		preserve array index
	LDX	4,U		variable bf
	LDD	,X		member buffer of bitFieldStruct
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,X
	ORB	,S+
	STB	,X
* Line lz77.c:60: post-decrement
	LDX	4,U		variable bf
* optim: optimizeLeax
	DEC	4,X		optim: optimizeLeax
* Line lz77.c:61: if
	LDX	4,U		variable bf
	LDB	4,X		member bitLeft of bitFieldStruct
	CMPB	#0
	BGE	L00200		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00199 removed
* Line lz77.c:61
* Line lz77.c:62: assignment: =
	CLRA
* LDB #$07 optim: optimizeStackOperations1
* PSHS B optim: optimizeStackOperations1
	LDX	4,U		variable bf
* optim: optimizeLeax
	LDB	#7		optim: optimizeStackOperations1
	STB	4,X		optim: optimizeLeax
* Line lz77.c:63: post-increment
	LDX	4,U		variable bf
	LEAX	2,X		member currentIndex of bitFieldStruct
	LDD	,X
	ADDD	#1
	STD	,X
L00200	EQU	*		else clause of if() started at lz77.c:61
* Useless label L00201 removed
* Useless label L00197 removed
* Line lz77.c:58: for increment(s)
	INC	-2,U
L00196	EQU	*
* Line lz77.c:58: for condition
	LDB	9,U		variable bitCount
	SUBB	-1,U		variable bitSet
	PSHS	B
	LDB	-2,U		variable `i', declared at lz77.c:58
	CMPB	,S+		compare with LSB
	LBLO	L00195
* optim: branchToNextLocation
* Useless label L00198 removed
* Useless label L00087 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION writebits(): defined at lz77.c:42
funcend_writebits	EQU *
funcsize_writebits	EQU	funcend_writebits-_writebits
_zerodw	IMPORT


	ENDSECTION




	SECTION	initgl




*******************************************************************************

* Initialize global variables.


	ENDSECTION




	SECTION	rodata


string_literals_start	EQU	*
string_literals_end	EQU	*


*******************************************************************************

* READ-ONLY GLOBAL VARIABLES


	ENDSECTION




	SECTION	rwdata


* Statically-initialized global variables
* Statically-initialized local static variables


	ENDSECTION




	SECTION	bss


bss_start	EQU	*
* Uninitialized global variables
_dicBitSize	EQU	*
	RMB	1		dicBitSize
_dicSize	EQU	*
	RMB	2		dicSize
_aheadBitSize	EQU	*
	RMB	1		aheadBitSize
_aheadSize	EQU	*
	RMB	2		aheadSize
_lps	EQU	*
	RMB	126		lps
* Uninitialized local static variables
bss_end	EQU	*


	ENDSECTION




*******************************************************************************

* Importing 8 utility routine(s).
MUL16	IMPORT
_memcmp	IMPORT
_memcpy	IMPORT
_memset	IMPORT
copyMem	IMPORT
shiftByteLeft	IMPORT
shiftByteRightUnsigned	IMPORT
shiftLeft	IMPORT


*******************************************************************************

	END
