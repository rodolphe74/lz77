* 6809 assembly program generated by cmoc 0.1.83


	SECTION	start


program_start	EXPORT
_main	IMPORT
INILIB	IMPORT
_exit	IMPORT
program_start	EQU	*
	LDD	#-1024		stack space in bytes
	LBSR	INILIB		initialize standard library and global variables
	LBSR	_main		call main()
	PSHS	B,A		send main() return value to exit()
	LBSR	_exit		use LBSR to respect calling convention


	ENDSECTION




	SECTION	code


_dicSize	IMPORT
_dicBitSize	IMPORT
_aheadSize	IMPORT
_aheadBitSize	IMPORT
___va_arg	IMPORT
_abs	IMPORT
_adddww	IMPORT
_atoi	IMPORT
_atol	IMPORT
_atoui	IMPORT
_atoul	IMPORT
_bsearch	IMPORT
_cmpdww	IMPORT
_compress	IMPORT
_delay	IMPORT
_divdwb	IMPORT
_divdww	IMPORT
_divmod16	IMPORT
_divmod8	IMPORT
_dwtoa	IMPORT
_enableCMOCFloatSupport	IMPORT
_exit	IMPORT
_initBitField	IMPORT
_initDefaultParameters	IMPORT
_initParameters	IMPORT
_isalnum	IMPORT
_isalpha	IMPORT
_isdigit	IMPORT
_isspace	IMPORT
_itoa10	IMPORT
_labs	IMPORT
_ltoa10	IMPORT
_main	EXPORT


*******************************************************************************

* FUNCTION main(): defined at tolzbuf.c:5
_main	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-5419,S
* Local non-static variable(s):
*  -5419,U:    2 bytes: v: unsigned int
*  -5417,U:    2 bytes: i: int
*  -5415,U:    5 bytes: bf: struct bitFieldStruct
*  -5410,U:  256 bytes: bitsMax: unsigned char[]
*  -5154,U:  512 bytes: values: unsigned int[]
*  -4642,U:  512 bytes: retrievedValues: unsigned int[]
*  -4130,U: 3840 bytes: buffer: unsigned char[]
*   -290,U:    2 bytes: ja: int
*   -288,U:   26 bytes: in: unsigned char[]
*   -262,U:  128 bytes: out: unsigned char[]
*   -134,U:  128 bytes: backToOriginal: unsigned char[]
*     -6,U:    2 bytes: osz: int
*     -4,U:    2 bytes: csz: int
*     -2,U:    2 bytes: bsz: int
* Line tolzbuf.c:13: function call: memset()
	LDD	#$0F00		constant expression: 3840 decimal, signed
	PSHS	B,A		argument 3 of memset(): int
	CLRA
* optim: removeClr
	PSHS	B,A		argument 2 of memset(): int
	LEAX	-4130,U		address of array buffer
	PSHS	X		argument 1 of memset(): unsigned char[]
	LBSR	_memset
	LEAS	6,S
* Line tolzbuf.c:14: function call: initBitField()
	LEAY	-4130,U		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LEAX	-5415,U		variable `bf', declared at tolzbuf.c:8
	PSHS	Y,X		optim: optimizePshsOps
	LBSR	_initBitField
	LEAS	4,S
* Line tolzbuf.c:15: function call: printf()
	LDY	#$0D		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LDX	#$0A		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	#$0100		decimal 256 signed
	PSHS	Y,X,B,A		optim: optimizePshsOps
	LEAX	S00080,PCR	"randomizing %d values%c%c"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	8,S
* Line tolzbuf.c:16: for init
* Line tolzbuf.c:16: init of variable i
	CLRA
	CLRB
	STD	-5417,U		variable i
	LBRA	L00092		jump to for condition
L00091	EQU	*
* Line tolzbuf.c:16: for body
* Line tolzbuf.c:17: assignment: =
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A
* Line tolzbuf.c:17: function call: rand()
	LBSR	_rand
	TFR	D,X		optim: stripExtraPulsX
	CLRA
	LDB	#$0E		decimal 14 signed
* optim: stripExtraPulsX
	LBSR	SDIV16
	ADDD	,S++
* Cast from `int' to byte: result already in B
	PSHS	B
	LDD	-5417,U		variable i
	LEAX	-5410,U		address of array bitsMax
	LEAX	D,X		add offset
	LDB	,S+
	STB	,X
* Line tolzbuf.c:18: assignment: =
* Line tolzbuf.c:18: function call: rand()
	LBSR	_rand
	PSHS	B,A
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		left side of shift: used and popped by shiftLeft
	LDD	-5417,U		variable i
	LEAX	-5410,U		address of array bitsMax
	LEAX	D,X		add offset
	LDB	,X		get r-value
	CLRA
	LBSR	shiftLeft
	PULS	X
	LBSR	SDIV16
	PSHS	B,A
	LDD	-5417,U		variable i
	LSLB
	ROLA
	LEAX	-5154,U		address of array values
	LEAX	D,X		add offset
	PULS	A,B		retrieve value to store
	STD	,X
* Useless label L00093 removed
* Line tolzbuf.c:16: for increment(s)
	LDD	-5417,U
	ADDD	#1
	STD	-5417,U
L00092	EQU	*
* Line tolzbuf.c:16: for condition
	LDD	-5417,U		variable i
	CMPD	#$0100
	LBLT	L00091
* optim: branchToNextLocation
* Useless label L00094 removed
* Line tolzbuf.c:21: function call: printf()
	LEAX	S00081,PCR	"\n"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line tolzbuf.c:22: function call: printf()
	LDY	#$0D		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LDX	#$0A		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	#$0100		decimal 256 signed
	PSHS	Y,X,B,A		optim: optimizePshsOps
	LEAX	S00082,PCR	"writing %d values%c%c"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	8,S
* Line tolzbuf.c:23: for init
* Line tolzbuf.c:23: init of variable i
	CLRA
	CLRB
	STD	-5417,U		variable i
	BRA	L00096		jump to for condition
L00095	EQU	*
* Line tolzbuf.c:23: for body
* Line tolzbuf.c:25: function call: writebits()
	LDD	-5417,U		variable i
	LEAX	-5410,U		address of array bitsMax
* optimizeLoadDX
	LDB	D,X		get r-value
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of writebits(): unsigned char
	LDD	-5417,U		variable i
	LSLB
	ROLA
	LEAX	-5154,U		address of array values
* optimizeLoadDX
	LDD	D,X		get r-value
	PSHS	B,A		argument 2 of writebits(): unsigned int
	LEAX	-5415,U		variable `bf', declared at tolzbuf.c:8
	PSHS	X		argument 1 of writebits(): struct bitFieldStruct *
	LBSR	_writebits
	LEAS	6,S
* Useless label L00097 removed
* Line tolzbuf.c:23: for increment(s)
	LDD	-5417,U
	ADDD	#1
	STD	-5417,U
L00096	EQU	*
* Line tolzbuf.c:23: for condition
	LDD	-5417,U		variable i
	CMPD	#$0100
	BLT	L00095
* optim: branchToNextLocation
* Useless label L00098 removed
* Line tolzbuf.c:27: function call: initBitField()
	LEAY	-4130,U		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LEAX	-5415,U		variable `bf', declared at tolzbuf.c:8
	PSHS	Y,X		optim: optimizePshsOps
	LBSR	_initBitField
	LEAS	4,S
* Line tolzbuf.c:28: function call: printf()
	LDY	#$0D		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LDX	#$0A		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	#$0100		decimal 256 signed
	PSHS	Y,X,B,A		optim: optimizePshsOps
	LEAX	S00083,PCR	"reading %d values%c%c"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	8,S
* Line tolzbuf.c:29: for init
* Line tolzbuf.c:29: init of variable i
	CLRA
	CLRB
	STD	-5417,U		variable i
	BRA	L00100		jump to for condition
L00099	EQU	*
* Line tolzbuf.c:29: for body
* Line tolzbuf.c:30: init of variable v
* Line tolzbuf.c:30: function call: readbits()
	LDD	-5417,U		variable i
	LEAX	-5410,U		address of array bitsMax
* optimizeLoadDX
	LDB	D,X		get r-value
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of readbits(): unsigned char
	LEAX	-5415,U		variable `bf', declared at tolzbuf.c:8
	PSHS	X		argument 1 of readbits(): struct bitFieldStruct *
	LBSR	_readbits
	LEAS	4,S
	STD	-5419,U		variable v
* Line tolzbuf.c:32: assignment: =
* optim: storeLoad
	PSHS	B,A
	LDD	-5417,U		variable i
	LSLB
	ROLA
	LEAX	-4642,U		address of array retrievedValues
	LEAX	D,X		add offset
	PULS	A,B		retrieve value to store
	STD	,X
* Useless label L00101 removed
* Line tolzbuf.c:29: for increment(s)
	LDD	-5417,U
	ADDD	#1
	STD	-5417,U
L00100	EQU	*
* Line tolzbuf.c:29: for condition
	LDD	-5417,U		variable i
	CMPD	#$0100
	BLT	L00099
* optim: branchToNextLocation
* Useless label L00102 removed
* Line tolzbuf.c:34: function call: printf()
	LDY	#$0D		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LDX	#$0A		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	#$0100		decimal 256 signed
	PSHS	Y,X,B,A		optim: optimizePshsOps
	LEAX	S00084,PCR	"comparing %d values%c%c"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	8,S
* Line tolzbuf.c:35: init of variable ja
	CLRA
	LDB	#$01		1
	STD	-290,U		variable ja
* Line tolzbuf.c:36: for init
* Line tolzbuf.c:36: init of variable i
* optim: stripExtraClrA_B
	CLRB
	STD	-5417,U		variable i
	BRA	L00104		jump to for condition
L00103	EQU	*
* Line tolzbuf.c:36: for body
* Line tolzbuf.c:37: if
	LDD	-5417,U		variable i
	LSLB
	ROLA
	LEAX	-4642,U		address of array retrievedValues
* optimizeLoadDX
	LDD	D,X		get r-value
	PSHS	B,A
	LDD	-5417,U		variable i
	LSLB
	ROLA
	LEAX	-5154,U		address of array values
* optimizeLoadDX
	LDD	D,X		get r-value
	CMPD	,S++
	BEQ	L00108		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00107 removed
* Line tolzbuf.c:37
* Line tolzbuf.c:38: assignment: =
	CLRA
	CLRB
	STD	-290,U
	BRA	L00106		break
L00108	EQU	*		else clause of if() started at tolzbuf.c:37
* Useless label L00109 removed
* Useless label L00105 removed
* Line tolzbuf.c:36: for increment(s)
	LDD	-5417,U
	ADDD	#1
	STD	-5417,U
L00104	EQU	*
* Line tolzbuf.c:36: for condition
	LDD	-5417,U		variable i
	CMPD	#$0100
	BLT	L00103
* optim: branchToNextLocation
L00106	EQU	*		end for
* Line tolzbuf.c:42: if
	LDD	-290,U		variable `ja', declared at tolzbuf.c:35
* optim: loadCmpZeroBeqOrBne
	BEQ	L00111		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00110 removed
* Line tolzbuf.c:42
* Line tolzbuf.c:42: function call: printf()
	LDX	#$0D		optim: transformPshsDPshsD
* optim: optimizePshsOps
	CLRA
	LDB	#$0A		decimal 10 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LEAX	S00085,PCR	"sch\xC3\xB6n%c%c"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	6,S
L00111	EQU	*		else clause of if() started at tolzbuf.c:42
* Useless label L00112 removed
* Line tolzbuf.c:46: init of variable in
	LDB	#$48		decimal 72 signed
	STB	-288,U		offset in variable in
	LDB	#$65		decimal 101 signed
	STB	-287,U		offset in variable in
	LDB	#$6C		decimal 108 signed
	STB	-286,U		offset in variable in
	LDB	#$6C		decimal 108 signed
	STB	-285,U		offset in variable in
	LDB	#$6F		decimal 111 signed
	STB	-284,U		offset in variable in
	LDB	#$20		decimal 32 signed
	STB	-283,U		offset in variable in
	LDB	#$66		decimal 102 signed
	STB	-282,U		offset in variable in
	LDB	#$72		decimal 114 signed
	STB	-281,U		offset in variable in
	LDB	#$69		decimal 105 signed
	STB	-280,U		offset in variable in
	LDB	#$65		decimal 101 signed
	STB	-279,U		offset in variable in
	LDB	#$6E		decimal 110 signed
	STB	-278,U		offset in variable in
	LDB	#$64		decimal 100 signed
	STB	-277,U		offset in variable in
	LDB	#$73		decimal 115 signed
	STB	-276,U		offset in variable in
	LDB	#$2C		decimal 44 signed
	STB	-275,U		offset in variable in
	LDB	#$20		decimal 32 signed
	STB	-274,U		offset in variable in
	LDB	#$48		decimal 72 signed
	STB	-273,U		offset in variable in
	LDB	#$65		decimal 101 signed
	STB	-272,U		offset in variable in
	LDB	#$6C		decimal 108 signed
	STB	-271,U		offset in variable in
	LDB	#$6C		decimal 108 signed
	STB	-270,U		offset in variable in
	LDB	#$6F		decimal 111 signed
	STB	-269,U		offset in variable in
	LDB	#$20		decimal 32 signed
	STB	-268,U		offset in variable in
	LDB	#$77		decimal 119 signed
	STB	-267,U		offset in variable in
	LDB	#$6F		decimal 111 signed
	STB	-266,U		offset in variable in
	LDB	#$72		decimal 114 signed
	STB	-265,U		offset in variable in
	LDB	#$6C		decimal 108 signed
	STB	-264,U		offset in variable in
	LDB	#$64		decimal 100 signed
	STB	-263,U		offset in variable in
* Line tolzbuf.c:50: init of variable osz
	CLRA
	LDB	#$1A		26
	STD	-6,U		variable osz
* Line tolzbuf.c:51: init of variable csz
* Line tolzbuf.c:51: function call: compress()
	LDB	#$80		optim: removeAndOrMulAddSub
	PSHS	B,A		argument 4 of compress(): int
	LEAX	-262,U		address of array out
* optim: optimizePshsOps
	LDD	-6,U		variable `osz', declared at tolzbuf.c:50
	PSHS	X,B,A		optim: optimizePshsOps
	LEAX	-288,U		address of array in
	PSHS	X		argument 1 of compress(): unsigned char[]
	LBSR	_compress
	LEAS	8,S
	STD	-4,U		variable csz
* Line tolzbuf.c:52: function call: printf()
	LDY	#$0D		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LDX	#$0A		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	-4,U		variable `csz', declared at tolzbuf.c:51
	PSHS	Y,X,B,A		optim: optimizePshsOps
	LEAX	S00086,PCR	"csz=%d%c%c"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	8,S
* Line tolzbuf.c:54: init of variable bsz
* Line tolzbuf.c:54: function call: uncompress()
	CLRA
	LDB	#$80		decimal 128 signed
	PSHS	B,A		argument 4 of uncompress(): int
	LEAX	-134,U		address of array backToOriginal
* optim: optimizePshsOps
	LDD	-4,U		variable `csz', declared at tolzbuf.c:51
	PSHS	X,B,A		optim: optimizePshsOps
	LEAX	-262,U		address of array out
	PSHS	X		argument 1 of uncompress(): unsigned char[]
	LBSR	_uncompress
	LEAS	8,S
	STD	-2,U		variable bsz
* Line tolzbuf.c:55: function call: printf()
	LDY	#$0D		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LDX	#$0A		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	-2,U		variable `bsz', declared at tolzbuf.c:54
	PSHS	Y,X,B,A		optim: optimizePshsOps
	LEAX	S00087,PCR	"bsz=%d%c%c"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	8,S
* Line tolzbuf.c:57: if
	LDD	-6,U		variable osz
	CMPD	-2,U		variable bsz
	BEQ	L00114		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00113 removed
* Line tolzbuf.c:57
* Line tolzbuf.c:58: function call: printf()
	LDX	#$0D		optim: transformPshsDPshsD
* optim: optimizePshsOps
	CLRA
	LDB	#$0A		decimal 10 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LEAX	S00088,PCR	"Messages differ!%c%c"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	6,S
* Line tolzbuf.c:59: return with value
	CLRA
	LDB	#$01		decimal 1 signed
	LBRA	L00079		return (tolzbuf.c:59)
L00114	EQU	*		else clause of if() started at tolzbuf.c:57
* Useless label L00115 removed
* Line tolzbuf.c:62: for init
* Line tolzbuf.c:62: init of variable i
	CLRA
	CLRB
	STD	-5417,U		variable i
	BRA	L00117		jump to for condition
L00116	EQU	*
* Line tolzbuf.c:62: for body
* Line tolzbuf.c:63: if
	LDD	-5417,U		variable i
	LEAX	-134,U		address of array backToOriginal
* optimizeLoadDX
	LDB	D,X		get r-value
	PSHS	B
	LDD	-5417,U		variable i
	LEAX	-288,U		address of array in
* optimizeLoadDX
	LDB	D,X		get r-value
	CMPB	,S+		compare with LSB
	BEQ	L00121		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00120 removed
* Line tolzbuf.c:63
* Line tolzbuf.c:64: function call: printf()
	LDY	#$0D		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LDX	#$0A		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	-5417,U		variable `i', declared at tolzbuf.c:62
	PSHS	Y,X,B,A		optim: optimizePshsOps
	LEAX	S00089,PCR	"Messages differ at %d%c%c"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	8,S
* Line tolzbuf.c:65: return with value
	CLRA
	LDB	#$01		decimal 1 signed
	BRA	L00079		return (tolzbuf.c:65)
L00121	EQU	*		else clause of if() started at tolzbuf.c:63
* Useless label L00122 removed
* Useless label L00118 removed
* Line tolzbuf.c:62: for increment(s)
	LDD	-5417,U
	ADDD	#1
	STD	-5417,U
L00117	EQU	*
* Line tolzbuf.c:62: for condition
	LDD	-5417,U		variable i
	CMPD	-2,U		variable bsz
	BLT	L00116
* optim: branchToNextLocation
* Useless label L00119 removed
* Line tolzbuf.c:68: function call: printf()
	LDX	#$0D		optim: transformPshsDPshsD
* optim: optimizePshsOps
	CLRA
	LDB	#$0A		decimal 10 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LEAX	S00090,PCR	"All good!%c%c"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	6,S
* Line tolzbuf.c:70: return with value
	CLRA
	CLRB
* optim: branchToNextLocation
L00079	EQU	*		end of main()
	LEAS	,U
	PULS	U,PC
* END FUNCTION main(): defined at tolzbuf.c:5
funcend_main	EQU *
funcsize_main	EQU	funcend_main-_main
_memchr	IMPORT
_memcmp	IMPORT
_memcpy	IMPORT
_memichr	IMPORT
_memicmp	IMPORT
_memmove	IMPORT
_memset	IMPORT
_memset16	IMPORT
_mulwb	IMPORT
_mulww	IMPORT
_printf	IMPORT
_putchar	IMPORT
_putstr	IMPORT
_qsort	IMPORT
_rand	IMPORT
_readbits	IMPORT
_readline	IMPORT
_readword	IMPORT
_sbrk	IMPORT
_sbrkmax	IMPORT
_setConsoleOutHook	IMPORT
_set_null_ptr_handler	IMPORT
_set_stack_overflow_handler	IMPORT
_sprintf	IMPORT
_sqrt16	IMPORT
_sqrt32	IMPORT
_srand	IMPORT
_strcat	IMPORT
_strchr	IMPORT
_strcmp	IMPORT
_strcpy	IMPORT
_stricmp	IMPORT
_strlen	IMPORT
_strlwr	IMPORT
_strncmp	IMPORT
_strncpy	IMPORT
_strstr	IMPORT
_strtol	IMPORT
_strtoul	IMPORT
_strupr	IMPORT
_subdww	IMPORT
_tolower	IMPORT
_toupper	IMPORT
_ultoa10	IMPORT
_uncompress	IMPORT
_utoa10	IMPORT
_vprintf	IMPORT
_vsprintf	IMPORT
_writebits	IMPORT
_zerodw	IMPORT


	ENDSECTION




	SECTION	initgl_start


INITGL	EXPORT
INITGL	EQU	*


	ENDSECTION




	SECTION	initgl




*******************************************************************************

* Initialize global variables.


	ENDSECTION




	SECTION	rodata


string_literals_start	EQU	*


*******************************************************************************

* STRING LITERALS
S00080	EQU	*
	FCC	"randomizing %d values%c%c"
	FCB	0
S00081	EQU	*
	FCB	$0A
	FCB	0
S00082	EQU	*
	FCC	"writing %d values%c%c"
	FCB	0
S00083	EQU	*
	FCC	"reading %d values%c%c"
	FCB	0
S00084	EQU	*
	FCC	"comparing %d values%c%c"
	FCB	0
S00085	EQU	*
	FCC	"sch"
	FCB	$C3
	FCB	$B6
	FCC	"n%c%c"
	FCB	0
S00086	EQU	*
	FCC	"csz=%d%c%c"
	FCB	0
S00087	EQU	*
	FCC	"bsz=%d%c%c"
	FCB	0
S00088	EQU	*
	FCC	"Messages differ!%c%c"
	FCB	0
S00089	EQU	*
	FCC	"Messages differ at %d%c%c"
	FCB	0
S00090	EQU	*
	FCC	"All good!%c%c"
	FCB	0
string_literals_end	EQU	*


*******************************************************************************

* READ-ONLY GLOBAL VARIABLES


	ENDSECTION




	SECTION	rwdata


* Statically-initialized global variables
* Statically-initialized local static variables


	ENDSECTION




	SECTION	bss


bss_start	EQU	*
* Uninitialized global variables
* Uninitialized local static variables
bss_end	EQU	*


	ENDSECTION




	SECTION	initgl_end


	RTS			end of global variable initialization


	ENDSECTION




*******************************************************************************



	SECTION	program_end


program_end	EXPORT
program_end	EQU	*


	ENDSECTION




*******************************************************************************

* Importing 10 utility routine(s).
SDIV16	IMPORT
_compress	IMPORT
_initBitField	IMPORT
_memset	IMPORT
_printf	IMPORT
_rand	IMPORT
_readbits	IMPORT
_uncompress	IMPORT
_writebits	IMPORT
shiftLeft	IMPORT


*******************************************************************************

	END
