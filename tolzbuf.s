* 6809 assembly program generated by cmoc 0.1.83


	SECTION	start


program_start	EXPORT
_main	IMPORT
INILIB	IMPORT
_exit	IMPORT
program_start	EQU	*
	LDD	#-1024		stack space in bytes
	LBSR	INILIB		initialize standard library and global variables
	LBSR	_main		call main()
	PSHS	B,A		send main() return value to exit()
	LBSR	_exit		use LBSR to respect calling convention


	ENDSECTION




	SECTION	code


_dicSize	IMPORT
_dicBitSize	IMPORT
_aheadSize	IMPORT
_aheadBitSize	IMPORT
___va_arg	IMPORT
_abs	IMPORT
_adddww	IMPORT
_atoi	IMPORT
_atol	IMPORT
_atoui	IMPORT
_atoul	IMPORT
_boyerMooreSearch	IMPORT
_bruteForceSearch	IMPORT
_bruteForceSearchOptim	IMPORT
_bsearch	IMPORT
_cmpdww	IMPORT
_compress	IMPORT
_delay	IMPORT
_divdwb	IMPORT
_divdww	IMPORT
_divmod16	IMPORT
_divmod8	IMPORT
_dwtoa	IMPORT
_enableCMOCFloatSupport	IMPORT
_exit	IMPORT
_findInDic	IMPORT
_initBitField	IMPORT
_initDefaultParameters	IMPORT
_initParameters	IMPORT
_isalnum	IMPORT
_isalpha	IMPORT
_isdigit	IMPORT
_isspace	IMPORT
_itoa10	IMPORT
_karpRabinSearch	IMPORT
_knuthMorrisPrattSearch	IMPORT
_labs	IMPORT
_ltoa10	IMPORT
_main	EXPORT


*******************************************************************************

* FUNCTION main(): defined at tolzbuf.c:5
_main	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-10540,S
* Local non-static variable(s):
* -10540,U:    2 bytes: v: unsigned int
* -10538,U:    2 bytes: i: int
* -10536,U:    5 bytes: bf: struct bitFieldStruct
* -10531,U:  256 bytes: bitsMax: unsigned char[]
* -10275,U:  512 bytes: values: unsigned int[]
*  -9763,U:  512 bytes: retrievedValues: unsigned int[]
*  -9251,U: 3840 bytes: buffer: unsigned char[]
*  -5411,U:    2 bytes: ja: int
*  -5409,U:   26 bytes: in: unsigned char[]
*  -5383,U:  128 bytes: out: unsigned char[]
*  -5255,U:  128 bytes: backToOriginal: unsigned char[]
*  -5127,U:    2 bytes: osz: int
*  -5125,U:    2 bytes: csz: int
*  -5123,U:    2 bytes: bsz: int
*  -5121,U: 1024 bytes: in1k: unsigned char[]
*  -4097,U: 2048 bytes: out1k: unsigned char[]
*  -2049,U: 2048 bytes: back1k: unsigned char[]
*     -1,U:    1 byte : ch: unsigned char
* Line tolzbuf.c:8: function call: initParameters()
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A		argument 4 of initParameters(): int
* optim: stripExtraClrA_B
	LDB	#$0F		decimal 15 signed
	PSHS	B,A		argument 3 of initParameters(): int
	LDB	#$09		optim: removeAndOrMulAddSub
	PSHS	B,A		argument 2 of initParameters(): int
	LDD	#$01FF		decimal 511 signed
	PSHS	B,A		argument 1 of initParameters(): int
	LBSR	_initParameters
	LEAS	8,S
* Line tolzbuf.c:18: function call: memset()
	LDD	#$0F00		constant expression: 3840 decimal, signed
	PSHS	B,A		argument 3 of memset(): int
	CLRA
* optim: removeClr
	PSHS	B,A		argument 2 of memset(): int
	LEAX	-9251,U		address of array buffer
	PSHS	X		argument 1 of memset(): unsigned char[]
	LBSR	_memset
	LEAS	6,S
* Line tolzbuf.c:19: function call: initBitField()
	LEAY	-9251,U		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LEAX	-10536,U	variable `bf', declared at tolzbuf.c:13
	PSHS	Y,X		optim: optimizePshsOps
	LBSR	_initBitField
	LEAS	4,S
* Line tolzbuf.c:20: function call: printf()
	LDY	#$0D		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LDX	#$0A		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	#$0100		decimal 256 signed
	PSHS	Y,X,B,A		optim: optimizePshsOps
	LEAX	S00086,PCR	"randomizing %d values%c%c"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	8,S
* Line tolzbuf.c:21: for init
* Line tolzbuf.c:21: init of variable i
	CLRA
	CLRB
	STD	-10538,U	variable i
	LBRA	L00103		jump to for condition
L00102	EQU	*
* Line tolzbuf.c:21: for body
* Line tolzbuf.c:22: assignment: =
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A
* Line tolzbuf.c:22: function call: rand()
	LBSR	_rand
	TFR	D,X		optim: stripExtraPulsX
	CLRA
	LDB	#$0E		decimal 14 signed
* optim: stripExtraPulsX
	LBSR	SDIV16
	ADDD	,S++
* Cast from `int' to byte: result already in B
	PSHS	B
	LDD	-10538,U	variable i
	LEAX	-10531,U	address of array bitsMax
	LEAX	D,X		add offset
	LDB	,S+
	STB	,X
* Line tolzbuf.c:23: assignment: =
* Line tolzbuf.c:23: function call: rand()
	LBSR	_rand
	PSHS	B,A
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		left side of shift: used and popped by shiftLeft
	LDD	-10538,U	variable i
	LEAX	-10531,U	address of array bitsMax
	LEAX	D,X		add offset
	LDB	,X		get r-value
	CLRA
	LBSR	shiftLeft
	PULS	X
	LBSR	SDIV16
	PSHS	B,A
	LDD	-10538,U	variable i
	LSLB
	ROLA
	LEAX	-10275,U	address of array values
	LEAX	D,X		add offset
	PULS	A,B		retrieve value to store
	STD	,X
* Useless label L00104 removed
* Line tolzbuf.c:21: for increment(s)
	LDD	-10538,U
	ADDD	#1
	STD	-10538,U
L00103	EQU	*
* Line tolzbuf.c:21: for condition
	LDD	-10538,U	variable i
	CMPD	#$0100
	LBLT	L00102
* optim: branchToNextLocation
* Useless label L00105 removed
* Line tolzbuf.c:26: function call: printf()
	LEAX	S00087,PCR	"\n"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line tolzbuf.c:27: function call: printf()
	LDY	#$0D		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LDX	#$0A		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	#$0100		decimal 256 signed
	PSHS	Y,X,B,A		optim: optimizePshsOps
	LEAX	S00088,PCR	"writing %d values%c%c"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	8,S
* Line tolzbuf.c:28: for init
* Line tolzbuf.c:28: init of variable i
	CLRA
	CLRB
	STD	-10538,U	variable i
	BRA	L00107		jump to for condition
L00106	EQU	*
* Line tolzbuf.c:28: for body
* Line tolzbuf.c:30: function call: writebits()
	LDD	-10538,U	variable i
	LEAX	-10531,U	address of array bitsMax
* optimizeLoadDX
	LDB	D,X		get r-value
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of writebits(): unsigned char
	LDD	-10538,U	variable i
	LSLB
	ROLA
	LEAX	-10275,U	address of array values
* optimizeLoadDX
	LDD	D,X		get r-value
	PSHS	B,A		argument 2 of writebits(): unsigned int
	LEAX	-10536,U	variable `bf', declared at tolzbuf.c:13
	PSHS	X		argument 1 of writebits(): struct bitFieldStruct *
	LBSR	_writebits
	LEAS	6,S
* Useless label L00108 removed
* Line tolzbuf.c:28: for increment(s)
	LDD	-10538,U
	ADDD	#1
	STD	-10538,U
L00107	EQU	*
* Line tolzbuf.c:28: for condition
	LDD	-10538,U	variable i
	CMPD	#$0100
	BLT	L00106
* optim: branchToNextLocation
* Useless label L00109 removed
* Line tolzbuf.c:32: function call: initBitField()
	LEAY	-9251,U		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LEAX	-10536,U	variable `bf', declared at tolzbuf.c:13
	PSHS	Y,X		optim: optimizePshsOps
	LBSR	_initBitField
	LEAS	4,S
* Line tolzbuf.c:33: function call: printf()
	LDY	#$0D		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LDX	#$0A		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	#$0100		decimal 256 signed
	PSHS	Y,X,B,A		optim: optimizePshsOps
	LEAX	S00089,PCR	"reading %d values%c%c"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	8,S
* Line tolzbuf.c:34: for init
* Line tolzbuf.c:34: init of variable i
	CLRA
	CLRB
	STD	-10538,U	variable i
	BRA	L00111		jump to for condition
L00110	EQU	*
* Line tolzbuf.c:34: for body
* Line tolzbuf.c:35: init of variable v
* Line tolzbuf.c:35: function call: readbits()
	LDD	-10538,U	variable i
	LEAX	-10531,U	address of array bitsMax
* optimizeLoadDX
	LDB	D,X		get r-value
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of readbits(): unsigned char
	LEAX	-10536,U	variable `bf', declared at tolzbuf.c:13
	PSHS	X		argument 1 of readbits(): struct bitFieldStruct *
	LBSR	_readbits
	LEAS	4,S
	STD	-10540,U	variable v
* Line tolzbuf.c:37: assignment: =
* optim: storeLoad
	PSHS	B,A
	LDD	-10538,U	variable i
	LSLB
	ROLA
	LEAX	-9763,U		address of array retrievedValues
	LEAX	D,X		add offset
	PULS	A,B		retrieve value to store
	STD	,X
* Useless label L00112 removed
* Line tolzbuf.c:34: for increment(s)
	LDD	-10538,U
	ADDD	#1
	STD	-10538,U
L00111	EQU	*
* Line tolzbuf.c:34: for condition
	LDD	-10538,U	variable i
	CMPD	#$0100
	BLT	L00110
* optim: branchToNextLocation
* Useless label L00113 removed
* Line tolzbuf.c:39: function call: printf()
	LDY	#$0D		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LDX	#$0A		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	#$0100		decimal 256 signed
	PSHS	Y,X,B,A		optim: optimizePshsOps
	LEAX	S00090,PCR	"comparing %d values%c%c"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	8,S
* Line tolzbuf.c:40: init of variable ja
	CLRA
	LDB	#$01		1
	STD	-5411,U		variable ja
* Line tolzbuf.c:41: for init
* Line tolzbuf.c:41: init of variable i
* optim: stripExtraClrA_B
	CLRB
	STD	-10538,U	variable i
	BRA	L00115		jump to for condition
L00114	EQU	*
* Line tolzbuf.c:41: for body
* Line tolzbuf.c:42: if
	LDD	-10538,U	variable i
	LSLB
	ROLA
	LEAX	-9763,U		address of array retrievedValues
* optimizeLoadDX
	LDD	D,X		get r-value
	PSHS	B,A
	LDD	-10538,U	variable i
	LSLB
	ROLA
	LEAX	-10275,U	address of array values
* optimizeLoadDX
	LDD	D,X		get r-value
	CMPD	,S++
	BEQ	L00119		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00118 removed
* Line tolzbuf.c:42
* Line tolzbuf.c:43: assignment: =
	CLRA
	CLRB
	STD	-5411,U
	BRA	L00117		break
L00119	EQU	*		else clause of if() started at tolzbuf.c:42
* Useless label L00120 removed
* Useless label L00116 removed
* Line tolzbuf.c:41: for increment(s)
	LDD	-10538,U
	ADDD	#1
	STD	-10538,U
L00115	EQU	*
* Line tolzbuf.c:41: for condition
	LDD	-10538,U	variable i
	CMPD	#$0100
	BLT	L00114
* optim: branchToNextLocation
L00117	EQU	*		end for
* Line tolzbuf.c:47: if
	LDD	-5411,U		variable `ja', declared at tolzbuf.c:40
* optim: loadCmpZeroBeqOrBne
	BEQ	L00122		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00121 removed
* Line tolzbuf.c:47
* Line tolzbuf.c:47: function call: printf()
	LDX	#$0D		optim: transformPshsDPshsD
* optim: optimizePshsOps
	CLRA
	LDB	#$0A		decimal 10 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LEAX	S00091,PCR	"sch\xC3\xB6n%c%c"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	6,S
L00122	EQU	*		else clause of if() started at tolzbuf.c:47
* Useless label L00123 removed
* Line tolzbuf.c:52: init of variable in
	LDB	#$48		decimal 72 signed
	STB	-5409,U		offset in variable in
	LDB	#$65		decimal 101 signed
	STB	-5408,U		offset in variable in
	LDB	#$6C		decimal 108 signed
	STB	-5407,U		offset in variable in
	LDB	#$6C		decimal 108 signed
	STB	-5406,U		offset in variable in
	LDB	#$6F		decimal 111 signed
	STB	-5405,U		offset in variable in
	LDB	#$20		decimal 32 signed
	STB	-5404,U		offset in variable in
	LDB	#$66		decimal 102 signed
	STB	-5403,U		offset in variable in
	LDB	#$72		decimal 114 signed
	STB	-5402,U		offset in variable in
	LDB	#$69		decimal 105 signed
	STB	-5401,U		offset in variable in
	LDB	#$65		decimal 101 signed
	STB	-5400,U		offset in variable in
	LDB	#$6E		decimal 110 signed
	STB	-5399,U		offset in variable in
	LDB	#$64		decimal 100 signed
	STB	-5398,U		offset in variable in
	LDB	#$73		decimal 115 signed
	STB	-5397,U		offset in variable in
	LDB	#$2C		decimal 44 signed
	STB	-5396,U		offset in variable in
	LDB	#$20		decimal 32 signed
	STB	-5395,U		offset in variable in
	LDB	#$48		decimal 72 signed
	STB	-5394,U		offset in variable in
	LDB	#$65		decimal 101 signed
	STB	-5393,U		offset in variable in
	LDB	#$6C		decimal 108 signed
	STB	-5392,U		offset in variable in
	LDB	#$6C		decimal 108 signed
	STB	-5391,U		offset in variable in
	LDB	#$6F		decimal 111 signed
	STB	-5390,U		offset in variable in
	LDB	#$20		decimal 32 signed
	STB	-5389,U		offset in variable in
	LDB	#$77		decimal 119 signed
	STB	-5388,U		offset in variable in
	LDB	#$6F		decimal 111 signed
	STB	-5387,U		offset in variable in
	LDB	#$72		decimal 114 signed
	STB	-5386,U		offset in variable in
	LDB	#$6C		decimal 108 signed
	STB	-5385,U		offset in variable in
	LDB	#$64		decimal 100 signed
	STB	-5384,U		offset in variable in
* Line tolzbuf.c:56: init of variable osz
	CLRA
	LDB	#$1A		26
	STD	-5127,U		variable osz
* Line tolzbuf.c:57: init of variable csz
* Line tolzbuf.c:57: function call: compress()
	LDB	#$80		optim: removeAndOrMulAddSub
	PSHS	B,A		argument 4 of compress(): int
	LEAX	-5383,U		address of array out
* optim: optimizePshsOps
	LDD	-5127,U		variable `osz', declared at tolzbuf.c:56
	PSHS	X,B,A		optim: optimizePshsOps
	LEAX	-5409,U		address of array in
	PSHS	X		argument 1 of compress(): unsigned char[]
	LBSR	_compress
	LEAS	8,S
	STD	-5125,U		variable csz
* Line tolzbuf.c:58: function call: printf()
	LDY	#$0D		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LDX	#$0A		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	-5125,U		variable `csz', declared at tolzbuf.c:57
	PSHS	Y,X,B,A		optim: optimizePshsOps
	LEAX	S00092,PCR	"csz=%d%c%c"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	8,S
* Line tolzbuf.c:60: init of variable bsz
* Line tolzbuf.c:60: function call: uncompress()
	CLRA
	LDB	#$80		decimal 128 signed
	PSHS	B,A		argument 4 of uncompress(): int
	LEAX	-5255,U		address of array backToOriginal
* optim: optimizePshsOps
	LDD	-5125,U		variable `csz', declared at tolzbuf.c:57
	PSHS	X,B,A		optim: optimizePshsOps
	LEAX	-5383,U		address of array out
	PSHS	X		argument 1 of uncompress(): unsigned char[]
	LBSR	_uncompress
	LEAS	8,S
	STD	-5123,U		variable bsz
* Line tolzbuf.c:61: function call: printf()
	LDY	#$0D		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LDX	#$0A		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	-5123,U		variable `bsz', declared at tolzbuf.c:60
	PSHS	Y,X,B,A		optim: optimizePshsOps
	LEAX	S00093,PCR	"bsz=%d%c%c"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	8,S
* Line tolzbuf.c:63: if
	LDD	-5127,U		variable osz
	CMPD	-5123,U		variable bsz
	BEQ	L00125		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00124 removed
* Line tolzbuf.c:63
* Line tolzbuf.c:64: function call: printf()
	LDX	#$0D		optim: transformPshsDPshsD
* optim: optimizePshsOps
	CLRA
	LDB	#$0A		decimal 10 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LEAX	S00094,PCR	"Messages differ!%c%c"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	6,S
* Line tolzbuf.c:65: return with value
	CLRA
	LDB	#$01		decimal 1 signed
	LBRA	L00085		return (tolzbuf.c:65)
L00125	EQU	*		else clause of if() started at tolzbuf.c:63
* Useless label L00126 removed
* Line tolzbuf.c:68: for init
* Line tolzbuf.c:68: init of variable i
	CLRA
	CLRB
	STD	-10538,U	variable i
	BRA	L00128		jump to for condition
L00127	EQU	*
* Line tolzbuf.c:68: for body
* Line tolzbuf.c:69: if
	LDD	-10538,U	variable i
	LEAX	-5255,U		address of array backToOriginal
* optimizeLoadDX
	LDB	D,X		get r-value
	PSHS	B
	LDD	-10538,U	variable i
	LEAX	-5409,U		address of array in
* optimizeLoadDX
	LDB	D,X		get r-value
	CMPB	,S+		compare with LSB
	BEQ	L00132		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00131 removed
* Line tolzbuf.c:69
* Line tolzbuf.c:70: function call: printf()
	LDY	#$0D		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LDX	#$0A		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	-10538,U	variable `i', declared at tolzbuf.c:68
	PSHS	Y,X,B,A		optim: optimizePshsOps
	LEAX	S00095,PCR	"Messages differ at %d%c%c"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	8,S
* Line tolzbuf.c:71: return with value
	CLRA
	LDB	#$01		decimal 1 signed
	LBRA	L00085		return (tolzbuf.c:71)
L00132	EQU	*		else clause of if() started at tolzbuf.c:69
* Useless label L00133 removed
* Useless label L00129 removed
* Line tolzbuf.c:68: for increment(s)
	LDD	-10538,U
	ADDD	#1
	STD	-10538,U
L00128	EQU	*
* Line tolzbuf.c:68: for condition
	LDD	-10538,U	variable i
	CMPD	-5123,U		variable bsz
	BLT	L00127
* optim: branchToNextLocation
* Useless label L00130 removed
* Line tolzbuf.c:74: function call: printf()
	LDX	#$0D		optim: transformPshsDPshsD
* optim: optimizePshsOps
	CLRA
	LDB	#$0A		decimal 10 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LEAX	S00096,PCR	"All good!%c%c"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	6,S
* Line tolzbuf.c:82: init of variable ch
	LDB	#$41		65
	STB	-1,U		variable ch
* Line tolzbuf.c:83: function call: printf()
	CLRA
	LDB	#$0D		decimal 13 signed
	PSHS	B,A		argument 4 of printf(): int
	LDB	#$0A		optim: removeAndOrMulAddSub
	PSHS	B,A		argument 3 of printf(): int
	LDD	#$0400		decimal 1024 signed
	PSHS	B,A		argument 2 of printf(): int
	LEAX	S00097,PCR	"filling a %d repetitive buffer%c%c"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	8,S
* Line tolzbuf.c:84: for init
* Line tolzbuf.c:84: init of variable i
	CLRA
	CLRB
	STD	-10538,U	variable i
	BRA	L00135		jump to for condition
L00134	EQU	*
* Line tolzbuf.c:84: for body
* Line tolzbuf.c:85: if
	LDX	-10538,U	left
	CLRA
	LDB	#$14		right
	LBSR	SDIV16
	ADDD	#0
	BNE	L00139		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00138 removed
* Line tolzbuf.c:85
* Line tolzbuf.c:86: post-increment
	INC	-1,U
* Line tolzbuf.c:87: function call: printf()
	LEAX	S00098,PCR	"+"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
L00139	EQU	*		else clause of if() started at tolzbuf.c:85
* Useless label L00140 removed
* Line tolzbuf.c:89: assignment: =
	LDB	-1,U		variable `ch', declared at tolzbuf.c:82
	PSHS	B
	LDD	-10538,U	variable i
	LEAX	-5121,U		address of array in1k
	LEAX	D,X		add offset
	LDB	,S+
	STB	,X
* Useless label L00136 removed
* Line tolzbuf.c:84: for increment(s)
	LDD	-10538,U
	ADDD	#1
	STD	-10538,U
L00135	EQU	*
* Line tolzbuf.c:84: for condition
	LDD	-10538,U	variable i
	CMPD	#$0400
	BLT	L00134
* optim: branchToNextLocation
* Useless label L00137 removed
* Line tolzbuf.c:91: function call: printf()
	LDX	#$0D		optim: transformPshsDPshsD
* optim: optimizePshsOps
	CLRA
	LDB	#$0A		decimal 10 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LEAX	S00099,PCR	"%c%c"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	6,S
* Line tolzbuf.c:92: function call: printf()
	LDY	#$0D		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LDX	#$0A		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	#$0400		decimal 1024 signed
	PSHS	Y,X,B,A		optim: optimizePshsOps
	LEAX	S00100,PCR	"compressing %d repetitive buffer%c%c"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	8,S
* Line tolzbuf.c:93: assignment: =
* Line tolzbuf.c:93: function call: compress()
	LDD	#$0800		constant expression: 2048 decimal, signed
	PSHS	B,A		argument 4 of compress(): int
	LEAX	-4097,U		address of array out1k
* optim: optimizePshsOps
	LDD	#$0400		decimal 1024 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LEAX	-5121,U		address of array in1k
	PSHS	X		argument 1 of compress(): unsigned char[]
	LBSR	_compress
	LEAS	8,S
	STD	-5125,U
* Line tolzbuf.c:94: function call: printf()
	LDY	#$0D		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LDX	#$0A		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	-5125,U		variable `csz', declared at tolzbuf.c:57
	PSHS	Y,X,B,A		optim: optimizePshsOps
	LEAX	S00101,PCR	"compressed size: %d%c%c"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	8,S
* Line tolzbuf.c:96: assignment: =
* Line tolzbuf.c:96: function call: uncompress()
	LDD	#$0800		constant expression: 2048 decimal, signed
	PSHS	B,A		argument 4 of uncompress(): int
	LEAX	-2049,U		address of array back1k
* optim: optimizePshsOps
	LDD	-5125,U		variable `csz', declared at tolzbuf.c:57
	PSHS	X,B,A		optim: optimizePshsOps
	LEAX	-4097,U		address of array out1k
	PSHS	X		argument 1 of uncompress(): unsigned char[]
	LBSR	_uncompress
	LEAS	8,S
	STD	-5123,U
* Line tolzbuf.c:97: function call: printf()
	LDY	#$0D		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LDX	#$0A		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	-5123,U		variable `bsz', declared at tolzbuf.c:60
	PSHS	Y,X,B,A		optim: optimizePshsOps
	LEAX	S00093,PCR	"bsz=%d%c%c"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	8,S
* Line tolzbuf.c:99: if
	LDD	-5123,U		variable `bsz', declared at tolzbuf.c:60
	CMPD	#1024
	BEQ	L00142		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00141 removed
* Line tolzbuf.c:99
* Line tolzbuf.c:100: function call: printf()
	LDX	#$0D		optim: transformPshsDPshsD
* optim: optimizePshsOps
	CLRA
	LDB	#$0A		decimal 10 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LEAX	S00094,PCR	"Messages differ!%c%c"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	6,S
* Line tolzbuf.c:101: return with value
	CLRA
	LDB	#$01		decimal 1 signed
	LBRA	L00085		return (tolzbuf.c:101)
L00142	EQU	*		else clause of if() started at tolzbuf.c:99
* Useless label L00143 removed
* Line tolzbuf.c:104: for init
* Line tolzbuf.c:104: init of variable i
	CLRA
	CLRB
	STD	-10538,U	variable i
	BRA	L00145		jump to for condition
L00144	EQU	*
* Line tolzbuf.c:104: for body
* Line tolzbuf.c:105: if
	LDD	-10538,U	variable i
	LEAX	-2049,U		address of array back1k
* optimizeLoadDX
	LDB	D,X		get r-value
	PSHS	B
	LDD	-10538,U	variable i
	LEAX	-5121,U		address of array in1k
* optimizeLoadDX
	LDB	D,X		get r-value
	CMPB	,S+		compare with LSB
	BEQ	L00149		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00148 removed
* Line tolzbuf.c:105
* Line tolzbuf.c:106: function call: printf()
	LDY	#$0D		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LDX	#$0A		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	-10538,U	variable `i', declared at tolzbuf.c:104
	PSHS	Y,X,B,A		optim: optimizePshsOps
	LEAX	S00095,PCR	"Messages differ at %d%c%c"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	8,S
* Line tolzbuf.c:107: return with value
	CLRA
	LDB	#$01		decimal 1 signed
	BRA	L00085		return (tolzbuf.c:107)
L00149	EQU	*		else clause of if() started at tolzbuf.c:105
* Useless label L00150 removed
* Useless label L00146 removed
* Line tolzbuf.c:104: for increment(s)
	LDD	-10538,U
	ADDD	#1
	STD	-10538,U
L00145	EQU	*
* Line tolzbuf.c:104: for condition
	LDD	-10538,U	variable i
	CMPD	-5123,U		variable bsz
	BLT	L00144
* optim: branchToNextLocation
* Useless label L00147 removed
* Line tolzbuf.c:110: function call: printf()
	LDX	#$0D		optim: transformPshsDPshsD
* optim: optimizePshsOps
	CLRA
	LDB	#$0A		decimal 10 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LEAX	S00096,PCR	"All good!%c%c"
	PSHS	X		argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	6,S
* Line tolzbuf.c:112: return with value
	CLRA
	CLRB
* optim: branchToNextLocation
L00085	EQU	*		end of main()
	LEAS	,U
	PULS	U,PC
* END FUNCTION main(): defined at tolzbuf.c:5
funcend_main	EQU *
funcsize_main	EQU	funcend_main-_main
_memchr	IMPORT
_memcmp	IMPORT
_memcpy	IMPORT
_memichr	IMPORT
_memicmp	IMPORT
_memmove	IMPORT
_memset	IMPORT
_memset16	IMPORT
_mulwb	IMPORT
_mulww	IMPORT
_printf	IMPORT
_putchar	IMPORT
_putstr	IMPORT
_qsort	IMPORT
_rand	IMPORT
_readbits	IMPORT
_readline	IMPORT
_readword	IMPORT
_sbrk	IMPORT
_sbrkmax	IMPORT
_setConsoleOutHook	IMPORT
_set_null_ptr_handler	IMPORT
_set_stack_overflow_handler	IMPORT
_sprintf	IMPORT
_sqrt16	IMPORT
_sqrt32	IMPORT
_srand	IMPORT
_strcat	IMPORT
_strchr	IMPORT
_strcmp	IMPORT
_strcpy	IMPORT
_stricmp	IMPORT
_strlen	IMPORT
_strlwr	IMPORT
_strncmp	IMPORT
_strncpy	IMPORT
_strstr	IMPORT
_strtol	IMPORT
_strtoul	IMPORT
_strupr	IMPORT
_subdww	IMPORT
_tolower	IMPORT
_toupper	IMPORT
_ultoa10	IMPORT
_uncompress	IMPORT
_utoa10	IMPORT
_vprintf	IMPORT
_vsprintf	IMPORT
_writebits	IMPORT
_zerodw	IMPORT


	ENDSECTION




	SECTION	initgl_start


INITGL	EXPORT
INITGL	EQU	*


	ENDSECTION




	SECTION	initgl




*******************************************************************************

* Initialize global variables.


	ENDSECTION




	SECTION	rodata


string_literals_start	EQU	*


*******************************************************************************

* STRING LITERALS
S00086	EQU	*
	FCC	"randomizing %d values%c%c"
	FCB	0
S00087	EQU	*
	FCB	$0A
	FCB	0
S00088	EQU	*
	FCC	"writing %d values%c%c"
	FCB	0
S00089	EQU	*
	FCC	"reading %d values%c%c"
	FCB	0
S00090	EQU	*
	FCC	"comparing %d values%c%c"
	FCB	0
S00091	EQU	*
	FCC	"sch"
	FCB	$C3
	FCB	$B6
	FCC	"n%c%c"
	FCB	0
S00092	EQU	*
	FCC	"csz=%d%c%c"
	FCB	0
S00093	EQU	*
	FCC	"bsz=%d%c%c"
	FCB	0
S00094	EQU	*
	FCC	"Messages differ!%c%c"
	FCB	0
S00095	EQU	*
	FCC	"Messages differ at %d%c%c"
	FCB	0
S00096	EQU	*
	FCC	"All good!%c%c"
	FCB	0
S00097	EQU	*
	FCC	"filling a %d repetitive buffer%c%c"
	FCB	0
S00098	EQU	*
	FCC	"+"
	FCB	0
S00099	EQU	*
	FCC	"%c%c"
	FCB	0
S00100	EQU	*
	FCC	"compressing %d repetitive buffer%c%c"
	FCB	0
S00101	EQU	*
	FCC	"compressed size: %d%c%c"
	FCB	0
string_literals_end	EQU	*


*******************************************************************************

* READ-ONLY GLOBAL VARIABLES


	ENDSECTION




	SECTION	rwdata


* Statically-initialized global variables
* Statically-initialized local static variables


	ENDSECTION




	SECTION	bss


bss_start	EQU	*
* Uninitialized global variables
* Uninitialized local static variables
bss_end	EQU	*


	ENDSECTION




	SECTION	initgl_end


	RTS			end of global variable initialization


	ENDSECTION




*******************************************************************************



	SECTION	program_end


program_end	EXPORT
program_end	EQU	*


	ENDSECTION




*******************************************************************************

* Importing 11 utility routine(s).
SDIV16	IMPORT
_compress	IMPORT
_initBitField	IMPORT
_initParameters	IMPORT
_memset	IMPORT
_printf	IMPORT
_rand	IMPORT
_readbits	IMPORT
_uncompress	IMPORT
_writebits	IMPORT
shiftLeft	IMPORT


*******************************************************************************

	END
